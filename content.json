{"meta":{"title":"Enderturtle's Blog","subtitle":null,"description":"信竞苦手","author":"Enderturtle","url":""},"pages":[{"title":"about","date":"2021-07-09T00:00:00.000Z","updated":"2021-10-03T06:13:40.772Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[qwqのEnderturtle]与&nbsp;Enderturtle&nbsp;（ htc ）对话中...bot_ui_ini()","keywords":"关于"},{"title":"categories","date":"2021-07-09T03:16:44.634Z","updated":"2021-02-10T15:19:51.000Z","comments":false,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":"","keywords":null},{"title":"coffee","date":"2020-03-31T05:48:57.000Z","updated":"2021-07-12T14:11:24.295Z","comments":false,"path":"coffee/index.html","permalink":"/coffee/index.html","excerpt":"","text":"忽地，她想到，为何莲子会相信我的体验故事呢。new Artitalk({appId:\"62g7OrWwsu6PtVA61URoyFOJ-MdYXbMMI\",appKey:\"cQrP0snPc0tfkCygBuw56JyU\",color1:\"#E6E6FA\",color2:\"#F0FFFF\",color3:\"black\"})","keywords":"秘封咖啡馆"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-02-10T15:19:51.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-10-03T02:36:33.323Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗叙别梦、扬州一觉。【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-02-10T15:19:51.000Z","comments":false,"path":"donate(not_finished)/index.html","permalink":"/donate(not_finished)/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"明文","date":"2018-12-19T15:11:06.000Z","updated":"2021-02-10T15:19:51.000Z","comments":false,"path":"exchange/index.html","permalink":"/exchange/index.html","excerpt":"The article has been encrypted, please enter your password to view.","text":"Please enter the password to read the blog. Incorrect Password! No content to display! U2FsdGVkX18r9TXzUdFjnIbiPoOAUEjfdaEr1jvxVC6VrfrQw7wrHvHdiAiGzVqsO0yxvLPYMzEAiKeeJn+ryXmFF3iWs0sYY53Hjtu5fs3BSOZR6w6l24kzfYux11fuaVy4/H2KlBbgyg2iS9yZP3LIE11fPKbyG+mqdZNx6WcLmIAXDUISD/1Aprcut4/cHnTE9GsxSVGmRYF6BeiiDkNorlaV3U5dbTBxl3FosrlkTSKi8oupyorE960bAorqJWGcGGupvvgW3x54zueNvji8kLFaOHodXMqkMGr4B5hR0JMeVTqoOhr3ioZASZCe5ygSqx2f7z+g3pMunLvWA/qAkLN9ywSsNXpLZTFj8r6C+oXEDYDmnnMDxEwB08zihS1ROwsDkCWym0LURVNWS2BjWVYrfTeXmRwzfyoKli7qGIRc+/Pi+SgVyhuYYUQhnTvKYyR0bt7S9VIytn+yq0NuktY72ovlNJL2Up86i3owJrxJLOYJt7+YjxluDxEePfLbNW9cgTQnFLfuRtVljgrfXQLq2UvEuc+Ahkk5wmo1xYaaCpHEp66Yg18dAm1VttZwEIHA7hxjdxJIem7zONtVaSypx1/QmLSKFz2MfXnpAjXuaF+kOIR404zS07GJdgojvlPJubY+B7GU//rkxUfaCF8JTz5T4OKT/YQ3pmPPD+YnAeydxptdHrCe+61VLWhOVHGI86lC3DFfhmm5fY3roN62SU48exWzHo7LcGtnvJi7ZJD0so/mQ4qGBHa8PhG1wZORorET2AgKH6IEqOE/3Lkg28upqTCMVYQCfrN50j16InnOGaZeP3oS6K1UtsRPwzJhncp2bPK5yQOXKgJKqyjE7po/qoKoyj9etkZzvY5vDqZxJ6qL3Y6rhjYraREFMdhXUwQUDreVZRlrkwpAW0NIMxUFQRJq0JrGcKlWV/PfRPS+GnLwXhPAZmmTTSCNJW9BdgK4ybV/5vJm8iKf6UHcSbF7Ux8IeriDSQoi5uw9ilF+m5yDT7ZlAdsdm5cnYOXeC7xXQjCJyGUlwE2E1qZk8WmEVqita/2TgmozVZ0cun968OKMhkus3emImcAHb5el1f5xcAi9oLLks35/pxbqXi7MaZf4YzBV4VbsQ8wvuSZbdzE4+l7z5YrdjjharZLlFXKCWtfeod/eipzbZuLH5LCIRJVyo3s1PGMuxtOIJrO6qOYbJDO0gPZezqzIl5iiU1D7zEaHTc0b+cyaXFCaKC41Gi8alTbV8S+tjRZMnbQNbCkUVDSIieLnAgCZtLqBC7jLzDp7nn3mhereorsb18dSdc/6NeTx5PbHi45mfxSl58Fp4OXVxS0dO1oy5tU6JMWcuxFxc9VrfV1e+JHy4QZyQao/G5X4/Hhp21qiXJNiaDdv6HVO6WfI9I1Q7pQKeeVXnIV67Si7Q4iMoe8rbxAI8+jtgmRvXJXbMKJhZ0wWvCNIcbixYoqL","keywords":"明文"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-02-10T15:19:51.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-02-10T15:19:51.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-10-03T02:49:34.030Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-10-03T05:53:19.181Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"主题Sakura修改自WordPress主题Sakura，感谢原作者MashiroHexo主题来源于Honjun，感谢大大！","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2020-03-31T05:31:41.000Z","updated":"2021-02-10T15:19:51.000Z","comments":false,"path":"tags/index-1.html","permalink":"/tags/index-1.html","excerpt":"","text":"","keywords":null},{"title":"tags","date":"2020-03-31T05:31:41.000Z","updated":"2021-02-10T15:19:51.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-10-26T13:39:24.852Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"冰雪小屋"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-02-10T15:19:51.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos=[{img:\"https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg\",title:\"朝花夕誓——于离别之朝束起约定之花\",status:\"已追完\",progress:100,jp:\"さよならの朝に約束の花をかざろう\",time:\"放送时间: 2018-02-24 SUN.\",desc:\" 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。\"},{img:\"https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg\",title:\"朝花夕誓——于离别之朝束起约定之花\",status:\"已追完\",progress:100,jp:\"さよならの朝に約束の花をかざろう\",time:\"2018-02-24 SUN.\",desc:\" 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。\"}].should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%}.should-ellipsis i{position:absolute;right:24px}.grey-text{color:#9e9e9e!important}.grey-text.text-darken-4{color:#212121!important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,:after,:before{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,.14),0 3px 1px -2px rgba(0,0,0,.12),0 1px 5px 0 rgba(0,0,0,.2);box-shadow:0 2px 2px 0 rgba(0,0,0,.14),0 3px 1px -2px rgba(0,0,0,.12),0 1px 5px 0 rgba(0,0,0,.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,.2),0 6px 20px 0 rgba(0,0,0,.19);box-shadow:0 8px 17px 0 rgba(0,0,0,.2),0 6px 20px 0 rgba(0,0,0,.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right!important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:400;color:rgba(0,0,0,.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=radio]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=radio]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=radio]:not(:checked)+span:after,[type=radio]:not(:checked)+span:before{border-radius:50%}[type=radio]:not(:checked)+span:after,[type=radio]:not(:checked)+span:before{border:2px solid #5a5a5a}[type=radio]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=checkbox]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=checkbox]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,.42)}[type=checkbox].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=checkbox].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0;z-index:0}input[type=checkbox]:not(:disabled).tabbed:focus~.lever::before,input[type=checkbox]:not(:disabled)~.lever:active:before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,.26);box-shadow:0 0 0 10px rgba(38,166,154,.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,.26)}番组计划这里将是永远的回忆window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"bangumi","date":"2020-03-20T08:00:00.000Z","updated":"2021-10-03T05:59:05.184Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"shuoshuo","date":"2020-03-31T05:48:57.000Z","updated":"2021-07-12T13:26:11.340Z","comments":false,"path":"shuoshuo/index.html","permalink":"/shuoshuo/index.html","excerpt":"","text":"new Artitalk({appId:\"Qa9KgBgGBMRl9fwiS7F3qat9-MdYXbMMI\",appKey:\"CIRDnIr8e5UoUQOnVX5NWLbe\",color1:\"#E6E6FA\",color2:\"#F0FFFF\",color3:\"black\"})","keywords":"碎碎念合集"}],"posts":[{"title":"本站食用指南~","slug":"本站食用指南","date":"+201314-05-20T05:57:00.000Z","updated":"2021-10-03T12:29:34.898Z","comments":true,"path":"201314/05/20/本站食用指南/","link":"","permalink":"/201314/05/20/本站食用指南/","excerpt":"","text":"【Update 2021.10.3】简单的建站背景一切的起因都是因为其他oier都有博客，羡慕好奇正好看到Mashiro的博客特别好看，于是想伸手拿来。于是，博客就建立了出来。简单的小站框架介绍本体Hexo强力驱动 gitee pages服务hexo功能很多gitee在国内速度很快图床图床采用picgo+github+jsdelivr可能会被封，但是好用啊！评论评论系统采用valine+leancloudvaline真的很优秀，都可以来试试【upd:2021.10.3】评论系统采用waline+leancloud+vercelwaline更为安全，且最近更新比较活跃【无缝衔接valine】目前版本缺点不支持QQ头像简单的小站内容介绍文章基本上我写的文章都是有关算法竞赛的题解和我自己学习的心路历程部分文章因为题目版权问题所以加锁了，实在抱歉如果有意要看加密问题的话，可以联系我邮箱，可能会有回复说说（我急切想把它改成在线的）【upd:2021.7.14 通过Artitalk解决了这个问题】基本上就是我个人的碎碎念,呜呜有的人把这个改成TODO，我觉得我这个懒人还是算了吧清单（我急切想把它改成在线的）清单目前分为番组，音乐，明文番组就是我追的番（由于本人过懒，目前好像只有超炮T）音乐主要是我喜爱的车车曲明文建议直接忽略（俗话说好奇心害死猫？）关于未来一些实验性功能也会加入其中来试水目前里面有 关于我 这个内容，可以去玩玩ww留言板欢迎在这里发表言论请不要引战，使用文明用语，符合社会主义核心价值观冰雪小屋这里都是我的好友和同学欢迎大家来这里找老婆 （？）咖啡秘封版聊？PIO对就是旁边的板娘，可以探索她的各种功能哦（嫌烦了也可以隐藏）药水制作师很好玩，推荐首页首页可以看好看的东方壁纸我的联系方式和公告首页壁纸右下角可以播放早苗淋雨曲pv一些想说的话建站不易，但是收获很多如果您发现里面的任意问题或者有建议，请务必联系我，我会好好感谢的ww那么请欣赏我的博客吧也许你发现了这篇文章的发布时间很独特ww","categories":[{"name":"博客相关","slug":"博客相关","permalink":"/categories/博客相关/"}],"tags":[],"keywords":[{"name":"博客相关","slug":"博客相关","permalink":"/categories/博客相关/"}]},{"title":"圣诞快乐","slug":"圣诞快乐","date":"2021-12-23T12:05:31.000Z","updated":"2021-12-23T12:36:13.551Z","comments":true,"path":"2021/12/23/圣诞快乐/","link":"","permalink":"/2021/12/23/圣诞快乐/","excerpt":"","text":"圣诞假期来了！第一次过圣诞假，舒服！第一学期感观还不错（虽然雀食学期有点短）XCPC也打了，认识了很多新的朋友（写这篇博客的目的是为了说明我还活着:D）（博客的夜间模式还有点bug，以后会修）","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"[LOJ 2737][JOISC 2016] 电报","slug":"loj2737","date":"2021-10-08T09:25:38.000Z","updated":"2021-11-25T02:24:29.245Z","comments":true,"path":"2021/10/08/loj2737/","link":"","permalink":"/2021/10/08/loj2737/","excerpt":"","text":"ProblemDescription给出$N$个点，每个点的出度均为$1$，给出这$N$个点初始指向的点 $A_i$，和改变这个点指向的目标所需要的价值$C_i$.求让所有点强连通的最小花费.Input$N$$A_i$ $C_i$…Output一行输出答案，即最小需要的代价。Sample Input4 2 2 1 3 4 2 3 3 Sample Output4 HINT$1 \\le N 10^5$时限200msSolutionAnalysis一个显然的结论是最后形成的图一定是个环。考虑一种贪心策略，即每次保证一个点的入度权值最大点。考虑保留之后形成的状态可能是若干个rho形状，考虑破环为链。即 分割最小的点。Attention特判一开始是环的情况Code//Code by Enderturtle #include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define repe(i,a) for(register int i=head[a];i;i=e[i].nxt) #define il inline #define pii pair&lt;int,int&gt; #define mp(a,b) make_pair(a,b) typedef long long ll; using namespace std; il void filejudge(){ freopen(&quot;.in&quot;,&quot;r&quot;,stdin); freopen(&quot;.out&quot;,&quot;w&quot;,stdout); } namespace io{ 这是快读 } using io::read; /*----- head end -----*/ const int N=100010; ll n,a[N],c[N],vis[N],mx[N],mx2[N],ans; int main(){ n=read(); rep(i,1,n) a[i]=read(),c[i]=read(),ans+=c[i]; rep(i,1,n){ int u=i,sz=0; for(;!vis[u];u=a[u]) vis[u]=i; if(i==vis[u]){ for(;vis[u]!=-1;u=a[u]){ sz++;vis[u]=-1;} if(sz==n){ puts(&quot;0&quot;);return 0;} }//环上的点被标记为-1 } rep(i,1,n){ mx[a[i]]=max(mx[a[i]],c[i]); if(vis[i]!=-1) mx2[a[i]]=max(mx2[a[i]],c[i]); //环上额外记录 } //贪心减少第一类点 rep(i,1,n) ans-=mx[i]; rep(i,1,n){ if(vis[i]==-1){ //环上找最小点 ll res=LLONG_MAX; for(register int u=i;vis[u]==-1;u=a[u]){ vis[u]=0; res=min(res,mx[u]-mx2[u]); } ans+=res; } } printf(&quot;%lld&quot;,ans); return 0; }","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"难度:中等","slug":"难度-中等","permalink":"/tags/难度-中等/"},{"name":"贪心","slug":"贪心","permalink":"/tags/贪心/"},{"name":"每日一题","slug":"每日一题","permalink":"/tags/每日一题/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"CCPC2019哈尔滨","slug":"CCPC2019哈尔滨","date":"2021-10-06T12:53:55.000Z","updated":"2021-10-06T13:15:38.338Z","comments":true,"path":"2021/10/06/CCPC2019哈尔滨/","link":"","permalink":"/2021/10/06/CCPC2019哈尔滨/","excerpt":"","text":"Contest linklink -&gt; gym 102394Experience注意卡常Problem A. Artful PaintingsDescription两类限制限制1：在$[L_i,R_i]$内部至少有$k$个被染色；限制2：在$[L_i,R_i]$外部至少有$k$个被染色；求在满足限制条件下，最少染色多少个。SolutionAnalysis容易知道可以二分。考虑用差分约束系统限制。Attention注意二分边界Code#include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define il inline #define inc(i,a,b) for(register int i=a;i&lt;=b;++i) #define fo(i,a,b) for(register int i=a;i&lt;=b;++i) #define dec(i,a,b) for(register int i=a;i&gt;=b;--i) #define fd(i,a,b) for(register int i=a;i&gt;=b;--i) #define pb push_back #define re register typedef long long ll; typedef double db; namespace io{ #define gc getchar il int read(){ int x=0;bool f=1;char ch=gc(); if(ch==&#39;-&#39;) f=0; while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48),ch=gc(); return f?x:-x; } } using io::read; using namespace std; /*---- head -----*/ const int N=3010; int n,m1,m2; struct node{ int l,r,k; } a1[N],a2[N]; struct Edge{ int u,v,w; };vector&lt;Edge&gt; e; int dis[N]; il bool spfa(){ rep(i,2,n+1) dis[i]=0x3f3f3f3f; dis[1]=0; rep(i,1,n){ bool flag=1; for(register unsigned j=0;j&lt;e.size();++j){ int u=e[j].u,v=e[j].v,w=e[j].w; if(dis[v]&gt;dis[u]+w){ dis[v]=dis[u]+w; flag=0; } } if(flag) return true; } for(register unsigned j=0;j&lt;e.size();++j){ int u=e[j].u,v=e[j].v,w=e[j].w; if(dis[v]&gt;dis[u]+w){ return false; } } return true; } int main(){ int T=read(); while(T--){ n=read();m1=read();m2=read(); rep(i,1,m1) a1[i].l=read(),a1[i].r=read(),a1[i].k=read(); rep(i,1,m2) a2[i].l=read(),a2[i].r=read(),a2[i].k=read(); int L=0,R=n; while(L&lt;R){ int mid=(L+R)&gt;&gt;1;e.clear(); rep(i,1,n){ e.pb((Edge){i,i+1,1}); e.pb((Edge){i+1,i,0}); } rep(i,1,m1){ e.pb((Edge){a1[i].r+1,a1[i].l,-a1[i].k}); } rep(i,1,m2){ e.pb((Edge){a2[i].l,a2[i].r+1,mid-a2[i].k}); } e.pb((Edge){1,n+1,mid}); e.pb((Edge){n+1,1,-mid}); if(spfa()) R=mid; else L=mid+1; } printf(&quot;%d\\n&quot;,L); } return 0; } Problem E. Exchanging GiftsDescription两种操作：操作1：给出一个序列。该序列编号为$i$。操作2：生成一个序列编号为$i$的序列，这个序列通过之前特定的两个序列相加获得；定义相加操作为集合合并，允许重复元素保证最后一步操作一定为操作2；求最后操作获得的序列的快乐值。定义快乐值为这个序列经过任意一种重新排序后，每个位置与原来位置上值不一样的个数的最大值SolutionAnalysis首先可以通过拓扑排序，统计出最后一个序列是由之前哪些序列贡献多少值获得。考虑影响快乐值的关键条件。即：最后序列中出现最多的元素个数。如果个数小于最后序列的长度，那么答案为序列长度；否则根据鸽巢原理，最后答案为（序列长度-出现最多元素个数）*2；Attention卡输入Code#include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define il inline #define inc(i,a,b) for(register int i=a;i&lt;=b;++i) #define fo(i,a,b) for(register int i=a;i&lt;=b;++i) #define dec(i,a,b) for(register int i=a;i&gt;=b;--i) #define fd(i,a,b) for(register int i=a;i&gt;=b;--i) #define pb push_back #define re register typedef long long ll; typedef double db; namespace io{ 这是快读; } using io::read; using namespace std; /*---- head -----*/ const int N=1000100; int n; vector&lt;int&gt; e[N];ll res[N]; int op[N][3]; il void init(){ rep(i,1,n){ e[i].clear();res[i]=0;} } il void topsort(){ res[n]=1; for(register int i=n;i&gt;=1;--i){ if(op[i][0]==1) continue; res[op[i][1]]+=res[i]; res[op[i][2]]+=res[i]; } } il void solve(){ int now=0;ll sum=0,ans=0; rep(i,1,n){ if(op[i][0]==2 || res[i]==0) continue; for(register unsigned j=0;j&lt;e[i].size();++j){ int v=e[i][j]; if(now==0){ now=v;sum+=res[i];} else if(now==v) sum+=res[i]; else{ sum-=res[i]; if(sum&lt;0) now=v,sum=-sum; } ans+=res[i]; } } sum=0; rep(i,1,n){ if(op[i][0]==2 || res[i]==0) continue; for(register unsigned j=0;j&lt;e[i].size();++j){ int v=e[i][j]; if(v==now) sum+=res[i]; } } if(sum*2ll&lt;ans) printf(&quot;%lld\\n&quot;,ans); else printf(&quot;%lld\\n&quot;,(ans-sum)*2ll); } int main(){ int T=read(); while(T--){ n=read(); init(); rep(i,1,n){ op[i][0]=read(); if(op[i][0]==1){ int sz=read(); while(sz--){ int x=read(); e[i].pb(x); } }else op[i][1]=read(),op[i][2]=read(); } topsort(); solve(); } return 0; } Problem L. LRU AlgorithmDescription给定一个操作序列，进入LRU系统。LRU系统解释：如果进入的值LRU内部有，将这个提到LRU顶。如果没有，此时如果LRU超出内存上限，删除底值。新的值将会放置LRU顶。给出$q$组询问，在内存上限为$m_i$时，是否LRU系统会出现给定的一个LRU序列。SolutionAnalysis性质：如果我们将内存上限设置无限大，并进行操作，那么在内存限制为$m$的时候，LRU序列即为无限大的情况的前$m$项。可以将这个进行hash，再进行判断对这个题可以通过再次校准来增加准确性。Attention卡读入Code#include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define il inline #define inc(i,a,b) for(register int i=a;i&lt;=b;++i) #define fo(i,a,b) for(register int i=a;i&lt;=b;++i) #define dec(i,a,b) for(register int i=a;i&gt;=b;--i) #define fd(i,a,b) for(register int i=a;i&gt;=b;--i) #define pb push_back #define re register typedef long long ll; typedef double db; namespace io{ 这是快读; } using io::read; using namespace std; /*---- head -----*/ const int N=5010; ll has[N][N],base=这是base,mod=这是mod; int n,q,o[N][N],a[N],top; int main (){ int T = read(); while (T--) { n = read(); q = read(); fo(i,1,n) a[i] = read(); rep(i,0,n) rep(j,0,n) o[i][j]=has[i][j]=0; top=0; rep(i,1,n){ int now=0; rep(j,1,top){ if(o[i-1][j]==a[i]){ now=j; break; } } if(now==0){ rep(j,1,top) o[i][j+1]=o[i-1][j]; o[i][1]=a[i]; top++; }else{ rep(j,1,now-1) o[i][j+1]=o[i-1][j]; rep(j,now+1,top) o[i][j]=o[i-1][j]; o[i][1]=a[i]; } rep(j,1,n) has[i][j]=(has[i][j-1]*base+o[i][j])%mod; } while(q--){ int m=read();ll res=0; rep(i,1,m){a[i]=read();res=(res*base+a[i])%mod;} bool f=0; rep(i,0,n){ if(res==has[i][m]){ bool fl=1; rep(j,1,m){ if(o[i][j]!=a[j]){ fl=0;break;} } if(fl){puts(&quot;Yes&quot;);f=1;break;} } } if(!f) puts(&quot;No&quot;); } } return 0; }","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"难度:中等","slug":"难度-中等","permalink":"/tags/难度-中等/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"更新日志[2021.10.3]","slug":"update2021-10-3","date":"2021-10-03T05:38:19.000Z","updated":"2021-10-03T12:29:59.282Z","comments":true,"path":"2021/10/03/update2021-10-3/","link":"","permalink":"/2021/10/03/update2021-10-3/","excerpt":"","text":"2021.10.3更新内容：主题颜色由橙色改为初音绿[#39C5BB]评论系统试运行Waline更换大量背景图片重做图床调整START:DASH!!增加新的联系方式友人帐-&gt;冰雪小屋2021.10.3 TODO调整404网页增加新板块- 版聊增加一言（尚不清楚加在哪一个page合理）增加新的lab希望大家多多提意见（就在这里的评论就行！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"/categories/博客相关/"}],"tags":[],"keywords":[{"name":"博客相关","slug":"博客相关","permalink":"/categories/博客相关/"}]},{"title":"国庆随笔","slug":"nationday2021","date":"2021-10-03T05:16:31.000Z","updated":"2021-10-03T05:32:03.257Z","comments":true,"path":"2021/10/03/nationday2021/","link":"","permalink":"/2021/10/03/nationday2021/","excerpt":"","text":"好像来到Cuhksz之后还没有写过文章？从苏州来到深圳(SZ to SZ)直观感觉学校真的很不错，依山傍水，环境优美。还有各种各样的活动，很用心，很尊重学生权利。（照片就不放哩）不过我的很多小伙伴要到国庆结束后才能开学，多放了一个月的假，xm。希望烦心事少少，开心事多多。还有深圳的夏天好热，都10月份了，还是很热，希望早点入秋吧！","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"NWERC2020","slug":"NWERC2020","date":"2021-10-02T10:14:55.000Z","updated":"2021-10-02T11:01:40.718Z","comments":true,"path":"2021/10/02/NWERC2020/","link":"","permalink":"/2021/10/02/NWERC2020/","excerpt":"","text":"Contest linklink -&gt; gym 103049Experience注意精度 Problem FProblem A. Atomic EnergyDescription完全背包，物品的体积是$1,2…n$ 价值是$a_1,a_2…a_n$给出$q$次询问，每次询问体积恰为$k$的背包的价值是多少$1 \\leq n \\leq 100,q \\leq 10^5\\ 1 \\leq a_i \\leq 10^9,1 \\leq k \\leq 10^9$SolutionAnalysis经典题，考虑大数据贪心，小数据DP。小数据进行完全背包DP，大数据按照密度（$\\frac{a_k}{k}$）贪心。Attention进行简单时间计算，DP的上限可以设为$10^5$。Code#include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define il inline #define inc(i,a,b) for(register int i=a;i&lt;=b;++i) #define fo(i,a,b) for(register int i=a;i&lt;=b;++i) #define dec(i,a,b) for(register int i=a;i&gt;=b;--i) #define fd(i,a,b) for(register int i=a;i&gt;=b;--i) #define pb push_back #define re register typedef long long ll; typedef double db; namespace io{ #define gc getchar il int read(){ int x=0;bool f=1;char ch=gc(); if(ch==&#39;-&#39;) f=0; while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48),ch=gc(); return f?x:-x; } } using io::read; using namespace std; /*---- head -----*/ #define N 100005 int n, q; ll a[N], f[N]; int main(){ n = read(); q = read(); fo (i, 1, n) a[i] = read(); fo (i, 1, n) f[i] = a[i]; int up = 100000; fo (i, n + 1, up) { f[i] = a[1] + f[i - 1]; fo (j, 1, n) f[i] = std::min(f[i], a[j] + f[i - j]); } fo (i, 1, q) { int now = read(); if (now &lt;= up) printf(&quot;%lld\\n&quot;, f[now]); else { ll ans; fo (k, 1, n) { int x = (now - up) / k; if ((now - up) % k) ++x; ll s = x * a[k] + f[now - x * k]; if (k == 1) ans = s; else ans = std::min(ans, s); } printf(&quot;%lld\\n&quot;, ans); } } return 0; } Problem D. Dragon BallsDescription在2维平面的第一象限上（包括坐标轴）有$n$个点你可以询问至多$1000$次，每次询问给出坐标$(x,y)$,每次会返回离该点的最近的点的距离的平方点的范围$0 \\leq x \\leq 10^6,0\\leq y \\leq 10^6$点的个数$1 \\leq n\\leq 7$返回的距离$0 \\leq d \\leq2\\times 10^{12}$SolutionAnalysis官方题解给出了众多解法，这边提出一个简易交互做法。第一次询问$(0,0)$得到返回的值$d$，考虑枚举以$(0,0)$为圆心，半径为$\\sqrt d$的圆上的整点。注意到$d \\leq 10^{12}$，在这个情景下，整点数目不会很多。Attention询问的点对$(x,y)$务必保证在数据范围内，否则评测姬会返回TLE。Code#include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define il inline #define inc(i,a,b) for(register int i=a;i&lt;=b;++i) #define fo(i,a,b) for(register int i=a;i&lt;=b;++i) #define dec(i,a,b) for(register int i=a;i&gt;=b;--i) #define fd(i,a,b) for(register int i=a;i&gt;=b;--i) #define pb push_back #define re register typedef long long ll; typedef double db; namespace io{ #define gc getchar il ll read(){ ll x=0;bool f=1;char ch=gc(); if(ch==&#39;-&#39;) f=0; while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48),ch=gc(); return f?x:-x; } } using io::read; using namespace std; /*---- head -----*/ int n; int main(){ n=read(); ll mn=1e6; rep(id,1,n){ puts(&quot;0 0&quot;); fflush(stdout); ll d=read(); if(d==0) continue; for(register ll x=0;x*x&lt;=d;++x){ ll y=(ll)(sqrt(d-x*x)+0.1); if((y*y+x*x)!=d) continue; if(x&gt;mn || y&gt;mn) continue; printf(&quot;%lld %lld\\n&quot;,x,y); fflush(stdout); ll d2=read(); if(d2==0) break; } } return 0; } Problem E. EndgameDescription在$n \\times n$的棋盘上两人进行移动。每次两人可以选择如下操作之一：1.进行两次给定的移动 2.移动到任意没有棋子的位置 3.不移动共有$n$个给定移动模式，负数表示向左或者向上，不能移动到界外初始状态Alice在$a_x,b_x$，Bob在$b_x,b_y$，Alice先动，如果Alice能抓到Bob，则Alice获胜；如果Alice能走到一个Bob不能走到的点，则平局在这个点；其他情况，Bob获胜。$2 \\leq n \\leq 10^5$SolutionAnalysis对于Alice获胜，直接判断是否能走到对于平局，考虑平局的点会很多（理由：移动模式的数量级在$n$，棋盘有$n \\times n$个格点）考虑随机化平局的点，如果能判断就平局；其他情况Bob获胜。Attention待补严谨证明Code#include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define il inline #define inc(i,a,b) for(register int i=a;i&lt;=b;++i) #define fo(i,a,b) for(register int i=a;i&lt;=b;++i) #define dec(i,a,b) for(register int i=a;i&gt;=b;--i) #define fd(i,a,b) for(register int i=a;i&gt;=b;--i) #define pb push_back #define re register typedef long long ll; typedef double db; namespace io{ #define gc getchar il int read(){ int x=0;bool f=1;char ch=gc(); if(ch==&#39;-&#39;) f=0; while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48),ch=gc(); return f?x:-x; } } using io::read; using namespace std; /*---- head -----*/ #define mp make_pair map&lt;pair&lt;int,int&gt; ,bool&gt; table; pair&lt;int,int&gt; a[100010]; int n,ax,ay,bx,by; il bool ok(int dx,int dy,int x,int y){ if(dx==0 &amp;&amp; dy==0) return 1; if(table[mp(dx,dy)]) return 1; rep(i,1,n){ int nx=x+a[i].first; int ny=y+a[i].second; if(nx&lt;1 || ny&lt;1 || nx&gt;n || ny&gt;n) continue; if(table[mp(dx-a[i].first,dy-a[i].second)]) return 1; } return 0; } int main(){ n=read(); ax=read(),ay=read(),bx=read(),by=read(); rep(i,1,n){ int dx=read(),dy=read(); table[make_pair(dx,dy)]=1; a[i]=make_pair(dx,dy); } if(ok(bx-ax,by-ay,ax,ay)){ puts(&quot;Alice wins&quot;);return 0;} int T=500; while(T--){ int x=rand()%n+1,y=rand()%n+1; if(!ok(x-bx,y-by,bx,by)){ printf(&quot;tie %d %d&quot;,x,y); return 0; } } puts(&quot;Bob wins&quot;); return 0; } Problem J. Joint ExcavationDescription蛮有趣的一个题给一个$n$个点$m$条边的无向连通图。求构造一种方案。删除图中的一条简单路径，使剩下的部分可以分成两个集合$S_1,S_2$，满足$|S_1| = |S_2|$，$S_1$与$S_2$不连通。保证数据给出一组解。$1\\leq n \\leq 210^5,0\\leq m \\le 210^5$SolutionAnalysis考虑一个基本性质，无向图的dfs树是没有横叉边，只有返祖边的。如果删除dfs树从根开始的一条路径，那么各个子树一定不互相连通。此时题目完全等价于：给定一棵树，从根节点删除一条路径，使剩余完整的子树可以分成数量相同的两部分。考虑一种贪心策略：对于一个点的轻儿子，我们将分配给$S_1$或者$S_2$（取决于当前谁的$|S|$更小）对于一个点的重儿子，我们考虑两种情况，如果分配给集合已经满足题意，就直接return，如果没有我们可以继续这个操作。Attention事实上，我们可以通过以下方式来证明为什么这样子操作是对的。对于一个子树，我们考虑当$|S_1| \\le |S_2|$就加入到$S_1$中。这样子每轮操作完，必定保证此时$|S_1| \\ge |S_2|$，每一层都保证这个，并且二者的差会逐渐缩小对于最后一层，一定有一个单独的叶子节点可以产生贡献（正/负），使得$|S_1|=|S_2|$。Code#include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define il inline #define inc(i,a,b) for(register int i=a;i&lt;=b;++i) #define fo(i,a,b) for(register int i=a;i&lt;=b;++i) #define dec(i,a,b) for(register int i=a;i&gt;=b;--i) #define fd(i,a,b) for(register int i=a;i&gt;=b;--i) #define pb push_back #define re register typedef long long ll; typedef double db; namespace io{ #define gc getchar il int read(){ int x=0;bool f=1;char ch=gc(); if(ch==&#39;-&#39;) f=0; while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48),ch=gc(); return f?x:-x; } } using io::read; using namespace std; /*---- head -----*/ const int N=200100,M=200100; struct node{ int sz,v; il bool operator &lt;(const node &amp; other) const{ return sz&gt;other.sz; } };vector&lt;node&gt; g[N]; struct Edge{ int v,nxt; } e[M&lt;&lt;1];int head[N],tot; bool vis[N]; il int dfs(int u){ // cerr&lt;&lt;u&lt;&lt;endl; vis[u]=1; int sz=1; for(register int i=head[u];i;i=e[i].nxt){ int v=e[i].v; if(vis[v]) continue; int sz_v=dfs(v); sz+=sz_v; g[u].push_back((node){sz_v,v}); } sort(g[u].begin(),g[u].end()); return sz; } int suma,sumb,ans,res[N],a[N],b[N],cnt_a,cnt_b; il void solve(int u){ res[++ans]=u; for(register unsigned i=1;i&lt;g[u].size();++i){ int v=g[u][i].v,sz=g[u][i].sz; if(suma&lt;=sumb){ suma+=sz; a[++cnt_a]=v; } else{ sumb+=sz; b[++cnt_b]=v; } } if(g[u].size()){ int v=g[u][0].v,sz=g[u][0].sz; if(suma+sz==sumb){ suma+=sz; a[++cnt_a]=v; return; } if(sumb+sz==suma){ sumb+=sz; b[++cnt_b]=v; return; } solve(v); } } int n,m; il void add_edge(int u,int v){ e[++tot]=(Edge){v,head[u]}; head[u]=tot; } il void print(int u){ printf(&quot;%d &quot;,u); for(register unsigned i=0;i&lt;g[u].size();++i){ int v=g[u][i].v; print(v); } } int main(){ n=read();m=read(); rep(i,1,m){ int u=read(),v=read(); add_edge(u,v); add_edge(v,u); } dfs(1); solve(1); printf(&quot;%d %d\\n&quot;,ans,suma); rep(i,1,ans) printf(&quot;%d &quot;,res[i]); puts(&quot;&quot;); rep(i,1,cnt_a) print(a[i]); puts(&quot;&quot;); rep(i,1,cnt_b) print(b[i]); puts(&quot;&quot;); return 0; }","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"难度:简单","slug":"难度-简单","permalink":"/tags/难度-简单/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"gym102114A","slug":"gym102114A","date":"2021-09-30T00:30:54.000Z","updated":"2021-09-30T00:47:35.193Z","comments":true,"path":"2021/09/30/gym102114A/","link":"","permalink":"/2021/09/30/gym102114A/","excerpt":"","text":"这份代码RE，待调ProblemDescription给一张仙人掌图，求$\\sum(i \\otimes j \\otimes maxflow(i,j))$$\\otimes$ 表示异或InputThe first line contains one integer T, indicating the number of test cases.The following lines describe all the test cases. For each test case:The first line contains two integers n and m.Each of the following m lines contains three integers u, v and w, indicating a bidirectional edge between vertex u and vertex v that can transmit at most w bits per second in each direction.It is guaranteed that the sum of n in all test cases does not exceed 106 and the size of the standard input file does not exceed 26 MiB.OutputFor each test case, print the answer in one line.Sample Input2 3 3 1 2 5 2 3 6 3 1 5 5 6 1 2 5 2 3 6 3 1 5 3 4 6 4 5 5 5 3 6 Sample Output27 116 HINTSolutionAnalysis问题一：考虑对于一棵树，我们只需要从大到小插入边就可以统计$maxflow$。问题二：对于仙人掌，我们考虑对于环该如何操作，环的$maxflow$是两条的$maxflow$，我们可以通过将这个环上的最小边破开将最小边的权值加入到其他边上，转换为问题一。Attention尚不明确为什么RECode#include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define il inline typedef long long ll; const int N=1e5+10,M=2e5+10; using namespace std; struct Edge{ int u,v; ll w; int nxt; il bool operator &lt;(const Edge &amp;other) const{ return w&gt;other.w; } } e[M],edge[M&lt;&lt;1],tmp[M];int head[N],tot,cnt; il void add_edge(int u,int v,ll w){ ++tot; e[tot].u=u;e[tot].v=v;e[tot].w=w;e[tot].nxt=head[u]; head[u]=tot; } int n,m; namespace find_union{ int fa[N]; il void init(){ rep(i,1,n) fa[i]=i;} il int find(int x){ if(x==fa[x]) return x;return fa[x]=find(fa[x]);} il void merge(int x,int y){ fa[y]=x;} } int dfs_clock,dfn[N],low[N],fa[N],from[N]; il void circle(int u,int v,int lst){ int num=0; while(v!=u){ tmp[++num]=e[from[v]]; v=fa[v]; } tmp[++num]=e[lst]; ll res=LLONG_MAX; rep(i,1,num){ if(tmp[i].w&lt;res){ res=tmp[i].w; v=i; } } rep(i,1,num){ if(i==v) continue; edge[++cnt]=tmp[i]; edge[cnt].w+=res; } } il void tarjan(int u,int f){ dfn[u]=low[u]=++dfs_clock; fa[u]=f; for(register int i=head[u];i;i=e[i].nxt){ int v=e[i].v; if(v==f) continue; if(!dfn[v]){ from[v]=i;tarjan(v,u);low[u]=min(low[u],low[v]);} else low[u]=min(low[u],dfn[v]); } for(register int i=head[u];i;i=e[i].nxt){ int v=e[i].v; if(low[v]&gt;dfn[u]) edge[++cnt]=e[i]; else if(dfn[v]&gt;dfn[u] &amp;&amp; fa[v]!=u) circle(u,v,i); } // cerr&lt;&lt;u&lt;&lt;&#39; &#39;&lt;&lt;dfn[u]&lt;&lt;&#39; &#39;&lt;&lt;low[u]&lt;&lt;endl; } unsigned long long ans,c[N][31][2]; il void init(){ dfs_clock=tot=cnt=0; ans=0; find_union::init(); rep(i,1,n){ head[i]=dfn[i]=low[i]=fa[i]=0; rep(j,0,30){ c[i][j][0]=((i&gt;&gt;j)&amp;1)^1; c[i][j][1]=c[i][j][0]^1; } } } int main(){ int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init(); rep(i,1,m){ int u,v;ll w;scanf(&quot;%d%d%lld&quot;,&amp;u,&amp;v,&amp;w); add_edge(u,v,w); add_edge(v,u,w); } tarjan(1,-1); sort(edge+1,edge+1+cnt); rep(i,1,cnt){ int fu=find_union::find(edge[i].u); int fv=find_union::find(edge[i].v); ll w=edge[i].w; rep(j,0,30){ ll k=(w&amp;(1ll&lt;&lt;j)); k=bool(k); ans+=c[fu][j][0]*c[fv][j][k^1]*(1ll&lt;&lt;j); ans+=c[fu][j][1]*c[fv][j][k]*(1ll&lt;&lt;j); // cerr&lt;&lt;fv&lt;&lt;&#39; &#39;&lt;&lt;j&lt;&lt;&#39; &#39;&lt;&lt;c[fv][j][0]&lt;&lt;&#39; &#39;&lt;&lt;c[fv][j][1]&lt;&lt;endl; } // cerr&lt;&lt;ans&lt;&lt;endl; find_union::merge(fu,fv); rep(j,0,30){ c[fu][j][0]+=c[fv][j][0]; c[fu][j][1]+=c[fv][j][1]; } } printf(&quot;%llu\\n&quot;,ans); } return 0; }","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"难度:中等","slug":"难度-中等","permalink":"/tags/难度-中等/"},{"name":"每日一题","slug":"每日一题","permalink":"/tags/每日一题/"},{"name":"图论","slug":"图论","permalink":"/tags/图论/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"arc092_f Two Faced Edges","slug":"arc092f","date":"2021-09-27T01:05:43.000Z","updated":"2021-09-28T01:30:27.271Z","comments":true,"path":"2021/09/27/arc092f/","link":"","permalink":"/2021/09/27/arc092f/","excerpt":"","text":"ProblemDescription给定一个$n$个点，$m$条边的有向无环无重边图。求判断若一条边$edge$翻转后，强连通分量数量是否变化。$1\\le N \\le 1000$$1 \\leq M \\leq 200,000$Input$N$ $M$$u_1$ $v_1$……$u_m$ $v_m$Output$M$​ linessame or diffSample Input5 9 3 2 3 1 4 1 4 2 3 5 5 3 3 4 1 2 2 5 Sample Outputsame same same same same diff diff diff diff HINTAtcoder跑得飞快SolutionAnalysis考虑一条边$u$​-&gt;$v$​什么时候会变，考虑忽略这条边1.$v$可到达$u$2.$v$可到达$u$以上两者条件当且仅当满足一个条件强连通分量就会变化考虑如何计算(1) 直接记录对于每个点$v$可到达的所有点$u$；(2) 考虑强制走第一条边​ 记录每个点首先来自于哪个点​ $p$：$v_1…v_k$​​ $q$：$v_k…v_1$​ 如果$p$和$q$相同，表示这是唯一一条边，如果忽略这条边，二者将不可达。Attention$O(nm)$Code#include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define il inline using namespace std; const int N=1010,M=200100; vector&lt;int&gt; e[N]; struct node{ int u,v; } g[M]; int vis[N][N],p[N][N],q[N][N]; il void dfs1(int u,int *a){ a[u]=1; for(register unsigned i=0;i&lt;e[u].size();++i){ if(a[e[u][i]]) continue; dfs1(e[u][i],a); } } il void dfs(int u,int *a,int w){ a[u]=w; for(register unsigned i=0;i&lt;e[u].size();++i){ if(a[e[u][i]]) continue; dfs(e[u][i],a,w); } } int n,m; int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,1,m){ scanf(&quot;%d%d&quot;,&amp;g[i].u,&amp;g[i].v); e[g[i].u].push_back(g[i].v); } rep(u,1,n){ dfs1(u,vis[u]); p[u][u]=q[u][u]=u; for(register unsigned i=0;i&lt;e[u].size();++i){ if(p[u][e[u][i]]) continue; dfs(e[u][i],p[u],e[u][i]); } reverse(e[u].begin(),e[u].end()); for(register unsigned i=0;i&lt;e[u].size();++i){ if(q[u][e[u][i]]) continue; dfs(e[u][i],q[u],e[u][i]); } } rep(i,1,m){ if(vis[g[i].v][g[i].u]^(p[g[i].u][g[i].v]!=q[g[i].u][g[i].v])) puts(&quot;diff&quot;); else puts(&quot;same&quot;); } return 0; }","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"难度:简单","slug":"难度-简单","permalink":"/tags/难度-简单/"},{"name":"atcoder","slug":"atcoder","permalink":"/tags/atcoder/"},{"name":"每日一题","slug":"每日一题","permalink":"/tags/每日一题/"},{"name":"思维","slug":"思维","permalink":"/tags/思维/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"arc092_d Two Sequences","slug":"arc092d","date":"2021-09-26T00:24:36.000Z","updated":"2021-09-26T01:07:25.887Z","comments":true,"path":"2021/09/26/arc092d/","link":"","permalink":"/2021/09/26/arc092d/","excerpt":"","text":"ProblemDescription给定n个数的数组A和数组B，求所有A[i]+B[j]的异或和(1&lt;=i,j&lt;=n)。n&lt;=200000。Inputn$a_1,a_2…a_n$$b_1,b_2…b_3$OutputPrint the result of the computation.Sample Input6 4 6 0 0 3 3 0 5 6 5 0 3 Sample Output8 HINT$n&lt;=200000$SolutionAnalysis考虑低位对高位的贡献。对于某一位$k$，考虑什么情况下$a_i+b_j$对这位产生贡献。显然的事实是如果$a_i+b_j$​对$k$产生了贡献，那么只会低位对高位产生贡献即：$base=(1&lt;&lt;(k+1))-1$只需考虑$a_i\\&amp;base$​和$b_i\\&amp;base$​对$k$这位的贡献。显然的是$max(a_i+b_j)=(base&lt;&lt;1)$​，即$a_i+b_j$的最高位不会大于$k+1$；考虑什么时候不产生贡献：(1) $a_i+b_j &lt; (1&lt;&lt;k)$(2) $(1&lt;&lt;(k+1))\\le a_i+b_j &lt;(1&lt;&lt;(k+1)+(1&lt;&lt;k))$对每层${b}$按照${b\\&amp;base}$排序，对于每个$a_i$产生的贡献即为$A$:$a_i+b_j\\ge(1&lt;&lt;k)$$B$:$(1&lt;&lt;(k+1))\\le a_i+b_j &lt;(1&lt;&lt;(k+1)+(1&lt;&lt;k))$$sum=A-B$Attention注意二分边界Code#include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define il inline typedef long long ll; using namespace std; il int read(){ int x;scanf(&quot;%d&quot;,&amp;x);return x;} const int N=200010; ll a[N],b[N],c[N];int n; il ll find(ll x,ll v){ v-=x; int l=1,r=n,res=0; while(l&lt;=r){ int mid=(l+r)&gt;&gt;1; if(c[mid]&gt;=v){ res=mid;l=mid+1;} else r=mid-1; } return res; } int main(){ n=read(); rep(i,1,n) a[i]=read(); rep(i,1,n) b[i]=read(); ll ans=0; rep(k,1,29){ ll base=(1&lt;&lt;k)-1,sum=0; rep(i,1,n) c[i]=(b[i]&amp;base); sort(c+1,c+1+n,greater&lt;ll&gt;()); rep(i,1,n) sum+=find(a[i]&amp;base,(1&lt;&lt;(k-1))); rep(i,1,n) sum-=find(a[i]&amp;base,(1&lt;&lt;k))-find(a[i]&amp;base,(1&lt;&lt;k)+(1&lt;&lt;(k-1))); if(sum&amp;1) ans+=(1&lt;&lt;(k-1)); } printf(&quot;%lld\\n&quot;,ans); return 0; }","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"难度:中等","slug":"难度-中等","permalink":"/tags/难度-中等/"},{"name":"atcoder","slug":"atcoder","permalink":"/tags/atcoder/"},{"name":"每日一题","slug":"每日一题","permalink":"/tags/每日一题/"},{"name":"思维","slug":"思维","permalink":"/tags/思维/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"CF643G Choosing Ads","slug":"CF643G-Choosing-Ads","date":"2021-07-09T15:53:36.000Z","updated":"2021-07-09T16:08:28.147Z","comments":true,"path":"2021/07/09/CF643G-Choosing-Ads/","link":"","permalink":"/2021/07/09/CF643G-Choosing-Ads/","excerpt":"","text":"ProblemDescription给定一个长度为$n$的序列和一个整数 $p$。有 $m$ 个操作，操作要么是区间赋值，要么是询问区间内出现次数至少占 $p$% 的数。输出询问的答案时，可以包含错的数，也可以重复输出，但对的数一定要在答案中，且输出的数的个数不超过$[\\frac{100}{p}]$（下取整）Input第一行$n$，$m$，$p$。接下来$m$行是询问 包含$opt$，$l$，$r$，$a$（可无）。如果$opt=1$表示区间$[l,r]$赋值为$a$如果$opt=2$表示询问$[l,r]$Output对每一个$opt=2$，先输出个数，再输出具体数字Sample Input5 9 33 1 2 1 3 3 2 1 5 2 1 5 2 1 3 2 3 3 1 2 4 5 2 1 5 2 3 5 1 4 5 1 2 1 5 Sample Output3 1 2 3 2 1 3 2 2 1 3 1 1000 1000 1 5 2 5 3 2 1 5 HINT$n,m \\leq 1.5\\times 10^3$$20 \\leq p \\leq 100$SolutionAnalysis考虑$p&gt;50$时，我们采用绝对众数投票法获得答案同理，如果$p\\leq50$我们可以统计一部分可能的众数来获得答案保留的名单个数应该为$\\frac{100}{q}$Attention可用重载运算符减小代码数量Code//Code by Enderturtle #include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define repe(i,a) for(register int i=head[a];i;i=e[i].nxt) #define il inline #define pii pair&lt;int,int&gt; #define mp(a,b) make_pair(a,b) typedef long long ll; using namespace std; il void filejudge(){ freopen(&quot;.in&quot;,&quot;r&quot;,stdin); freopen(&quot;.out&quot;,&quot;w&quot;,stdout); } il int read(){ int x=0;bool f=1;char ch=getchar(); while(!isdigit(ch)){if(ch==&#39;-&#39;) f=0;ch=getchar();} while(isdigit(ch)){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();} return f?x:-x; } /*----- head end -----*/ const int N=150100; #define ls (o&lt;&lt;1) #define rs ((o&lt;&lt;1)|1) int n,m,p; struct node{ int num[8],sum[8],tag,len; il node operator +(const node &amp; other) const{ node res=other; res.tag=0; rep(i,1,len){ bool f=0; rep(j,1,res.len) if(num[i]==res.num[j]){ res.sum[j]+=sum[i]; f=1; } if(f) continue; if(res.len&lt;p){ res.len++; res.num[res.len]=num[i]; res.sum[res.len]=sum[i]; }else{ int mn=INT_MAX,pos=0; rep(j,1,res.len) if(res.sum[j]&lt;mn){ mn=res.sum[j];pos=j;} if(res.sum[pos]&gt;sum[i]) rep(j,1,res.len) res.sum[j]-=sum[i]; else{ int k=res.sum[pos]; rep(j,1,res.len) res.sum[j]-=k; res.sum[pos]=sum[i]-k; res.num[pos]=num[i]; int lst=0; rep(j,1,res.len) if(res.sum[j]&gt;0){ lst++; res.num[lst]=res.num[j]; res.sum[lst]=res.sum[j]; } res.len=lst; } } } return res; } } t[N&lt;&lt;2]; int a[N]; il void up(int o){ t[o]=t[ls]+t[rs];} il void down(int o,int oo,int sum){ t[oo].tag=t[o].tag; t[oo].len=1; t[oo].num[1]=t[o].tag; t[oo].sum[1]=sum; } il void pushdown(int o,int l,int r){ if(!t[o].tag) return; int mid=(l+r)&gt;&gt;1; down(o,ls,mid-l+1); down(o,rs,r-mid); t[o].tag=0; } il void make(int o,int l,int r,int addv){ t[o].tag=addv; t[o].len=1; t[o].num[1]=addv; t[o].sum[1]=r-l+1; } il void update(int o,int l,int r,int L,int R,int addv){ if(l&gt;=L &amp;&amp; r&lt;=R){ make(o,l,r,addv);return;} pushdown(o,l,r); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) update(ls,l,mid,L,R,addv); if(R&gt;mid) update(rs,mid+1,r,L,R,addv); up(o); } il node query(int o,int l,int r,int L,int R){ if(l&gt;=L &amp;&amp; r&lt;=R) return t[o]; pushdown(o,l,r); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid &amp;&amp; R&gt;mid) return query(ls,l,mid,L,R)+query(rs,mid+1,r,L,R); if(L&lt;=mid) return query(ls,l,mid,L,R); if(R&gt;mid) return query(rs,mid+1,r,L,R); } il void build(int o,int l,int r){ if(l==r){ make(o,l,r,a[l]);return;} int mid=(l+r)&gt;&gt;1; build(ls,l,mid); build(rs,mid+1,r); up(o); } int main(){ n=read();m=read();p=read();p=100/p; rep(i,1,n) a[i]=read(); build(1,1,n); while(m--){ int opt=read(),l=read(),r=read(); if(opt==1){ int addv=read(); update(1,1,n,l,r,addv); }else{ node ans=query(1,1,n,l,r); printf(&quot;%d &quot;,ans.len); rep(i,1,ans.len) printf(&quot;%d &quot;,ans.num[i]); puts(&quot;&quot;); } } return 0; } 太菜了，码力不足，写了1h","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"/tags/线段树/"},{"name":"难度:中等","slug":"难度-中等","permalink":"/tags/难度-中等/"},{"name":"众数","slug":"众数","permalink":"/tags/众数/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"新春快乐","slug":"新春快乐","date":"2021-02-11T16:00:00.000Z","updated":"2021-02-11T15:59:12.000Z","comments":true,"path":"2021/02/12/新春快乐/","link":"","permalink":"/2021/02/12/新春快乐/","excerpt":"","text":"祝大家新春快乐！好久没更新了抱歉希望我能2021高考成功吧！","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"完全平方数","slug":"完全平方数","date":"2020-04-28T09:27:15.000Z","updated":"2021-02-10T15:19:51.000Z","comments":true,"path":"2020/04/28/完全平方数/","link":"","permalink":"/2020/04/28/完全平方数/","excerpt":"","text":"ProblemDescription本题1不是完全平方数小 X 自幼就很喜欢数。但奇怪的是，他十分讨厌完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。这天是小X的生日，小 W 想送一个数给他作为生日礼物。当然他不能送一个小X讨厌的数。他列出了所有小X不讨厌的数，然后选取了第 K个数送给了小X。小X很开心地收下了。然而现在小 W 却记不起送给小X的是哪个数了。你能帮他一下吗？Input包含多组测试数据。文件第一行有一个整数 T，表示测试数据的组数。 第2至第T+1*行每行有一个整数K描述一组数据，含义如题目中所描述。Output含T 行，分别对每组数据作出回答。第 i 行输出相应的第K个不是完全平方数的正整数倍的数。Sample Input4 1 13 100 1234567 Sample Output1 19 163 2030745 HINT$T&lt;=50$ $K&lt;=10^9$SolutionAnalysis还是不太清晰理解出莫比乌斯函数的本质，一上来就无脑直接令$\\mu^2$杜教筛二分。然而其实$\\mu$本身就已经是个容斥了，很完美符合了题目要求。Attention二分的上界和数据类型Code//Code by Enderturtle #include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define repe(i,a) for(register int i=head[a];i;i=e[i].nxt) #define il inline #define pii pair&lt;int,int&gt; #define mp(a,b) make_pair(a,b) typedef long long ll; using namespace std; il void filejudge(){ freopen(&quot;.in&quot;,&quot;r&quot;,stdin); freopen(&quot;.out&quot;,&quot;w&quot;,stdout); } il int read(){ int x=0;bool f=1;char ch=getchar(); while(!isdigit(ch)){if(ch==&#39;-&#39;) f=0;ch=getchar();} while(isdigit(ch)){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();} return f?x:-x; } /*----- head end -----*/ const int N=45010; bitset&lt;45001&gt; zhi;int pri[N],mu[N],tot; il void shai(){ const int MAXN=45000; mu[1]=1;zhi[1]=1; rep(i,2,MAXN){ if(zhi[i]==0) pri[++tot]=i,mu[i]=-1; for(register int j=1;j&lt;=tot &amp;&amp; pri[j]*i&lt;=MAXN;++j){ zhi[pri[j]*i]=1; if(i%pri[j]==0){ mu[pri[j]*i]=0; break; } mu[pri[j]*i]=-mu[i]; } } } il int check(int x){ int res=0; for(register int i=1;i*i&lt;=x;++i) res+=1ll*mu[i]*(x/(i*i)); return res; } int main(){ shai(); int T=read(); while(T--){ int k=read(); int l=1,r=(k&lt;&lt;1),ans=1; while(l&lt;=r){ int mid=((ll)l+(ll)r)&gt;&gt;1; int sum=check(mid); if(sum&gt;=k){ if(sum==k) ans=mid; r=mid-1; } else l=mid+1; } printf(&quot;%d\\n&quot;,ans); } return 0; }","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"难度:简单","slug":"难度-简单","permalink":"/tags/难度-简单/"},{"name":"数论","slug":"数论","permalink":"/tags/数论/"},{"name":"容斥","slug":"容斥","permalink":"/tags/容斥/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"[SDOI2013]随机数生成器","slug":"SDOI2013-随机数生成器","date":"2020-04-24T07:20:32.000Z","updated":"2021-02-10T15:19:51.000Z","comments":true,"path":"2020/04/24/SDOI2013-随机数生成器/","link":"","permalink":"/2020/04/24/SDOI2013-随机数生成器/","excerpt":"","text":"ProblemDescription小W喜欢读书，尤其喜欢读《约翰克里斯朵夫》。最近小W准备读一本新书，这本书一共有$P$页，页码范围为$0 \\cdots P-1$。小W很忙，所以每天只能读一页书。为了使事情有趣一些，他打算使用NOI2012上学习的线性同余法生成一个序列，来决定每天具体读哪一页。我们用Xi来表示通过这种方法生成出来的第$i$个数，也即小W第$i$天会读哪一页。这个方法需要设置$3$个参数$a,b,X1$，满足$0\\leq a,b,X1\\leq p-1$，且$a,b,X1$都是整数。按照下面的公式生成出来一系列的整数：$X_{i+1} \\equiv aX_i+b \\pmod p$。但是这种方法可能导致某两天读的页码一样。小W要读这本书的第$t$页，所以他想知道最早在哪一天能读到第t页，或者指出他永远不会读到第$t$页。Input输入含有多组数据，第一行一个正整数$T$，表示这个测试点内的数据组数。接下来T行，每行有五个整数$p，a，b，X1，t$，表示一组数据。保证$X1$和$t$都是合法的页码。 注意：$P$一定为质数。Output共$T$行，每行一个整数表示他最早读到第$t$页是哪一天。如果他永远不会读到第$t$页，输出-1。Sample Input3 7 1 1 3 3 7 2 2 2 0 7 2 2 2 1 Sample Output1 3 -1 HINT$2 \\leq p \\leq 10^9$SolutionAnalysis这其实是个非常简单的题，之所以记录一下题解是因为网上绝大部分的题解都是错的（至少我后来搜到的没有一个是正确的），关于一些特判讲的很含糊。我们设解为$n$分类讨论：$a=0$ ：显然只要特判$t=b$就结束了；$a=1$ ：直接解$t \\equiv X+(n-1)b$，注意要通过特判$b=0$和$t-x \\equiv gcd(p,b)$；$a=others$首先惯例大力推式子，根据简单的高中数列知识可以推到这样的式子：a^{n-1}(X-\\frac{b}{1-a}) \\equiv t-\\frac{b}{1-a}很多文章就直接左边式子$X-\\frac{b}{1-a}$直接除到了右边，这是显然不对的，因为这个式子可能为$0$。这个就导致了很多题解说要特判$t=x$的情况（但大多数题解都只认为这个只是加速了运算，跟正确性无关），所以我简单解释一下这个特判的重要性。我们简单回想一下，这个式子为$0$的必要条件应该是$X\\equiv \\frac{b}{1-a}$。此时如果该方程有解时$t-\\frac{b}{1-a} \\equiv 0$，也就是说$X=t$。所以说这种特判影响了正确性。同时也解决了case #1 #2中的对于解为$1$的特殊情况。Attention其他还有点小细节如在case #2 中的$n+1$不需要取模之类的。Code//Code by Enderturtle #include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define repe(i,a) for(register int i=head[a];i;i=e[i].nxt) #define il inline #define pii pair&lt;int,int&gt; #define mp(a,b) make_pair(a,b) typedef long long ll; using namespace std; il void filejudge(){ freopen(&quot;.in&quot;,&quot;r&quot;,stdin); freopen(&quot;.out&quot;,&quot;w&quot;,stdout); } il int read(){ int x=0;bool f=1;char ch=getchar(); while(!isdigit(ch)){if(ch==&#39;-&#39;) f=0;ch=getchar();} while(isdigit(ch)){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();} return f?x:-x; } /*----- head end -----*/ il ll ksm(ll x,ll y,ll mod){ ll res=1;x%=mod; while(y){ if(y&amp;1) res=res*x%mod; x=x*x%mod; y&gt;&gt;=1; } return res; } il ll inv(ll x,ll mod){ return ksm(x,mod-2,mod); } map&lt;ll,ll&gt; s; il ll bsgs(ll a,ll b,ll p){ s.clear(); ll m=ceil(sqrt(p)),now=b; rep(i,0,m){ s[now]=i; now=now*a%p; } a=ksm(a,m,p); now=a; rep(i,1,m){ if(s.find(now)!=s.end()) return 1ll*i*m-s[now]; now=now*a%p; } return -2; } il int gcd(int a,int b){ while(b){ int t=a; a=b; b=t%b; } return a; } il void solve(){ ll p=read(),a=read(),b=read(),x=read(),t=read(),ans=0; if(x==t) puts(&quot;1&quot;); else if(a==0){ if(b==t) puts(&quot;2&quot;); else puts(&quot;-1&quot;); }else if(a==1){ t=(t-x+p)%p; if(b==0 || t%gcd(b,p)) puts(&quot;-1&quot;); else{ ans=(t*inv(b,p)%p+1; printf(&quot;%lld\\n&quot;,ans); } }else{ ll res=b*inv((1-a+p)%p,p)%p; res=(t-res+p)%p*inv((x-res+p)%p,p)%p; ans=bsgs(a,res,p)+1; printf(&quot;%lld\\n&quot;,ans); } } int main(){ int T=read(); while(T--) solve(); return 0; }","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"难度:简单","slug":"难度-简单","permalink":"/tags/难度-简单/"},{"name":"BSGS","slug":"BSGS","permalink":"/tags/BSGS/"},{"name":"数论","slug":"数论","permalink":"/tags/数论/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"CF1336","slug":"CF1336","date":"2020-04-16T09:52:47.000Z","updated":"2021-02-10T15:19:51.000Z","comments":true,"path":"2020/04/16/CF1336/","link":"","permalink":"/2020/04/16/CF1336/","excerpt":"","text":"难得的国人赛，但我是憨憨。Problem AAnalysis考虑贪心，我一个点选了，那么这个点必然子树也选了，所以一个点$u$的贡献是$sz[u]-dep[u]$。直接排序选前$k$大的就行。Attention无Code//Code by Enderturtle #include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define repe(i,a) for(register int i=head[a];i;i=e[i].nxt) #define il inline #define pii pair&lt;int,int&gt; #define mp(a,b) make_pair(a,b) typedef long long ll; using namespace std; il void filejudge(){ freopen(&quot;.in&quot;,&quot;r&quot;,stdin); freopen(&quot;.out&quot;,&quot;w&quot;,stdout); } il int read(){ int x=0;bool f=1;char ch=getchar(); while(!isdigit(ch)){if(ch==&#39;-&#39;) f=0;ch=getchar();} while(isdigit(ch)){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();} return f?x:-x; } /*----- head end -----*/ const int N=2e5+10; struct Edge{ int v,nxt; } e[N&lt;&lt;1];int head[N],tot; il void add_edge(int u,int v){ e[++tot]=(Edge){v,head[u]};head[u]=tot;} il void link(int u,int v){ add_edge(u,v);add_edge(v,u);} int n,k,dep[N],sz[N],a[N]; ll ans; il void dfs(int u,int f){ dep[u]=dep[f]+1; sz[u]=1; repe(i,u){ int v=e[i].v; if(v==f) continue; dfs(v,u); sz[u]+=sz[v]; } a[u]=dep[u]-sz[u]; } int main(){ n=read();k=read(); rep(i,2,n){ int u=read(),v=read();link(u,v);} dfs(1,1);sort(a+1,a+1+n,greater&lt;int&gt;()); rep(i,1,k) ans+=(ll)(a[i]); printf(&quot;%lld\\n&quot;,ans); return 0; } Problem BAnalysis憨憨题。考虑如果我们固定了3个值中的最小值$mn$和最大值$mx$，那么根据简单的不等式我们可以知道第三个最佳的值是$\\frac{(mn+mx)}{2}$。枚举$mn$，确定$mx$，然后大力二分第三个值就行了。Attention（lower_bound在从小到大排序的数组中是找到第一个大于等于的值）Code//Code by Enderturtle #include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define repe(i,a) for(register int i=head[a];i;i=e[i].nxt) #define il inline #define pii pair&lt;int,int&gt; #define mp(a,b) make_pair(a,b) typedef long long ll; using namespace std; il void filejudge(){ freopen(&quot;.in&quot;,&quot;r&quot;,stdin); freopen(&quot;.out&quot;,&quot;w&quot;,stdout); } il int read(){ int x=0;bool f=1;char ch=getchar(); while(!isdigit(ch)){if(ch==&#39;-&#39;) f=0;ch=getchar();} while(isdigit(ch)){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();} return f?x:-x; } /*----- head end -----*/ const int N=1e5+10; const ll INF=LLONG_MAX; int r[N],g[N],b[N]; int nr,ng,nb; il ll calc(int x,int y,int z){ if(x&lt;=0 || y&lt;=0 || z&lt;=0 || x==(nr+1) || y==(ng+1) || z==(nb+1)) return INF; ll xx=(r[x]-g[y]),yy=(g[y]-b[z]),zz=(r[x]-b[z]); return xx*xx+yy*yy+zz*zz; } int main(){ int T=read(); while(T--){ nr=read();ng=read();nb=read(); rep(i,1,nr) r[i]=read();sort(r+1,r+1+nr);r[nr+1]=INT_MAX; rep(i,1,ng) g[i]=read();sort(g+1,g+1+ng);g[ng+1]=INT_MAX; rep(i,1,nb) b[i]=read();sort(b+1,b+1+nb);b[nb+1]=INT_MAX; int x,y,z; ll ans=LLONG_MAX; rep(i,1,nr){ x=i; y=lower_bound(g+1,g+1+ng,r[x])-g; if(y!=(ng+1)){ z=lower_bound(b+1,b+1+nb,(r[x]+g[y])/2)-b; ans=min(ans,calc(x,y,z)); ans=min(ans,calc(x,y,z-1)); } y--; if(y!=0){ z=lower_bound(b+1,b+1+nb,(r[x]+g[y])/2)-b; ans=min(ans,calc(x,y,z)); ans=min(ans,calc(x,y,z-1)); } z=lower_bound(b+1,b+1+nb,r[x])-b; if(z!=(nb+1)){ y=lower_bound(g+1,g+1+ng,(r[x]+b[z])/2)-g; ans=min(ans,calc(x,y,z)); ans=min(ans,calc(x,y-1,z)); } z--; if(z!=0){ y=lower_bound(g+1,g+1+ng,(r[x]+b[z])/2)-g; ans=min(ans,calc(x,y,z)); ans=min(ans,calc(x,y-1,z)); } } rep(i,1,ng){ y=i; z=lower_bound(b+1,b+1+nb,g[y])-b; if(z!=(nb+1)){ x=lower_bound(r+1,r+1+nr,(g[y]+b[z])/2)-r; ans=min(ans,calc(x,y,z)); ans=min(ans,calc(x-1,y,z)); } z--; if(z!=0){ x=lower_bound(r+1,r+1+nr,(g[y]+b[z])/2)-r; ans=min(ans,calc(x,y,z)); ans=min(ans,calc(x-1,y,z)); } } printf(&quot;%lld\\n&quot;,ans); } return 0; } Problem CAnalysis区间$dp$，将$T$长度补到$len_s$（保证正确性），$dp[l][r]$表示目前已经匹配了$T$中的$[l,r]$的字符串。Attention无Code//Code by Enderturtle #include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define repe(i,a) for(register int i=head[a];i;i=e[i].nxt) #define il inline #define pii pair&lt;int,int&gt; #define mp(a,b) make_pair(a,b) typedef long long ll; using namespace std; il void filejudge(){ freopen(&quot;.in&quot;,&quot;r&quot;,stdin); freopen(&quot;.out&quot;,&quot;w&quot;,stdout); } il int read(){ int x=0;bool f=1;char ch=getchar(); while(!isdigit(ch)){if(ch==&#39;-&#39;) f=0;ch=getchar();} while(isdigit(ch)){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();} return f?x:-x; } /*----- head end -----*/ const int N=3010,mod=998244353; int n,m; ll dp[N][N],ans; char s[N],t[N]; il void add(ll &amp;x,ll y){ x+=y;if(x&gt;=mod) x-=mod;} int main(){ scanf(&quot;%s&quot;,s+1);n=strlen(s+1); scanf(&quot;%s&quot;,t+1);m=strlen(t+1); rep(i,1,n+1) dp[i][i-1]=1; rep(i,1,n){ for(register int l=1,r=i;r&lt;=n;++l,++r){ if(l&gt;m || t[l]==s[i]) add(dp[l][r],dp[l+1][r]); if(r&gt;m || t[r]==s[i]) add(dp[l][r],dp[l][r-1]); } } rep(i,m,n) add(ans,dp[1][i]); printf(&quot;%lld&quot;,ans); return 0; } Problem DAnalysis等我想写再写Attention实际上是因为我菜Codeorz","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"总结","slug":"总结","permalink":"/tags/总结/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"[ZJOI2015]幻想乡战略游戏","slug":"ZJOI2015-幻想乡战略游戏","date":"2020-04-01T13:47:58.000Z","updated":"2021-02-10T15:19:51.000Z","comments":true,"path":"2020/04/01/ZJOI2015-幻想乡战略游戏/","link":"","permalink":"/2020/04/01/ZJOI2015-幻想乡战略游戏/","excerpt":"","text":"ProblemDescription傲娇少女幽香正在玩一个非常有趣的战略类游戏，本来这个游戏的地图其实还不算太大，幽香还能管得过来，但是不知道为什么现在的网游厂商把游戏的地图越做越大，以至于幽香一眼根本看不过来，更别说和别人打仗了。 在打仗之前，幽香现在面临一个非常基本的管理问题需要解决。 整个地图是一个树结构，一共有 $n$块空地，这些空地被 $n-1$条带权边连接起来，使得每两个点之间有一条唯一的路径将它们连接起来。在游戏中，幽香可能在空地上增加或者减少一些军队。同时，幽香可以在一个空地上放置一个补给站。 如果补给站在点 $u$ 上，并且空地 $v$上有 $d_v$ 个单位的军队，那么幽香每天就要花费 $d_v \\times \\text{dist}(u,v)$的金钱来补给这些军队。由于幽香需要补给所有的军队，因此幽香总共就要花费为 $\\sum (d_v \\times \\text{dist}(u,v))$（其中$1 \\leq v \\leq N$）的代价，$\\text{dist}(u,v)dist$表示 $u$个 $v$ 在树上的距离（唯一路径的权和）。 因为游戏的规定，幽香只能选择一个空地作为补给站。在游戏的过程中，幽香可能会在某些空地上制造一些军队，也可能会减少某些空地上的军队，进行了这样的操作以后，出于经济上的考虑，幽香往往可以移动他的补给站从而省一些钱。但是由于这个游戏的地图是在太大了，幽香无法轻易的进行最优的安排，你能帮帮她吗？ 你可以假定一开始所有空地上都没有军队。Input第一行两个数 n和 Q分别表示树的点数和幽香操作的个数，其中点从1到n标号。接下来 n-1 行，每行三个正整数 a,b,c，表示a和b之间有一条边权为c的边。接下来 Q 行，每行两个数 u,e，表示幽香在点 u上放了 e单位个军队（如果 e&lt;0，就相当于是幽香在 u上减少了 |e| 单位个军队，说白了就是$d_u←d_u+e$）。数据保证任何时刻每个点上的军队数量都是非负的。Output对于幽香的每个操作，输出操作完成以后，每天的最小花费，也即如果幽香选择最优的补给点进行补给时的花费。Sample Input10 5 1 2 1 2 3 1 2 4 1 1 5 1 2 6 1 2 7 1 5 8 1 7 9 1 1 10 1 3 1 2 1 8 1 3 1 4 1 Sample Output0 1 4 5 6 HINT对于所有数据，$1\\le c\\le 10^3$，$0\\le |e| \\le 10^30$，$1\\le n\\le10^5$ ，$1\\le Q\\le10^5$非常神奇的是，对于所有数据，这棵树上的点的度数都不超过 20。SolutionAnalysis考虑贪心，如果一个父子关系的点儿子比父亲优，那么答案一定在儿子方向（想想为什么，凸函数性质）但是这样很糟糕，我们可能会变成$O(n)$。考虑点分树，点分树保证了树高$log(n)$，那我们考虑如果一个点优就往这个点所在的子树的重心转移。Attention注意点分树上信息的维护（不具有直接父子传递性）Code$O(nlog^3n)$的垃圾代码//Code by Enderturtle #include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define repe(i,a) for(register int i=head[a];i;i=e[i].nxt) #define il inline #define pii pair&lt;int,int&gt; #define mp(a,b) make_pair(a,b) typedef long long ll; using namespace std; il void filejudge(){ freopen(&quot;.in&quot;,&quot;r&quot;,stdin); freopen(&quot;.out&quot;,&quot;w&quot;,stdout); } il int read(){ int x=0;bool f=1;char ch=getchar(); while(!isdigit(ch)){if(ch==&#39;-&#39;) f=0;ch=getchar();} while(isdigit(ch)){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();} return f?x:-x; } /*----- head end -----*/ const int N=100010; int n; struct Edge{ int v,w,nxt;} e[N&lt;&lt;1];int head[N],tot; il void add_edge(int u,int v,int w){ e[++tot]=(Edge){v,w,head[u]};head[u]=tot;} il void link(int u,int v,int w){ add_edge(u,v,w),add_edge(v,u,w);} namespace slpf{ int sz[N],fa[N],top[N],son[N];ll dep[N]; il void dfs1(int u,int f){ fa[u]=f;sz[u]=1; repe(i,u){ int v=e[i].v; if(v==f) continue; dep[v]=dep[u]+e[i].w; dfs1(v,u); sz[u]+=sz[v]; if(sz[v]&gt;sz[son[u]]) son[u]=v; } } il void dfs2(int u,int topf){ top[u]=topf; if(!son[u]) return; dfs2(son[u],topf); repe(i,u){ int v=e[i].v; if(v==fa[u] || v==son[u]) continue; dfs2(v,v); } } il int lca(int u,int v){ while(top[u]!=top[v]){ if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); u=fa[top[u]]; } if(dep[u]&gt;dep[v]) swap(u,v); return u; } il ll getdis(int u,int v){ return dep[u]+dep[v]-2ll*dep[lca(u,v)]; } il void init(){ dfs1(1,1);dfs2(1,1);} }using slpf::getdis; Edge g[N&lt;&lt;1];int nhead[N],ntot; il void n_add_edge(int u,int v,int w){ g[++ntot]=(Edge){v,w,nhead[u]};nhead[u]=ntot;} int fa[N],sz[N],mx[N],treesz,root;bool vis[N]; il void getsz(int u,int f){ sz[u]=1; repe(i,u){ int v=e[i].v; if(v==f || vis[v]) continue; getsz(v,u); sz[u]+=sz[v]; } // cerr&lt;&lt;u&lt;&lt;&#39; &#39;&lt;&lt;sz[u]&lt;&lt;endl; } il void getroot(int u,int f){ // cerr&lt;&lt;u&lt;&lt;&#39; &#39;&lt;&lt;f&lt;&lt;endl; mx[u]=0; repe(i,u){ int v=e[i].v; if(v==f || vis[v]) continue; getroot(v,u); mx[u]=max(mx[u],sz[v]); } mx[u]=max(mx[u],treesz-mx[u]); // cerr&lt;&lt;mx[u]&lt;&lt;endl; if(mx[u]&lt;mx[root]) root=u; } il void nxtroot(int u,int f){ getsz(u,f); treesz=sz[u];root=0; getroot(u,f); } ll sum[N],sum_dis[N],sum_f[N]; il void modify(int u,int w){ sum[u]+=w; int now=u; for(;fa[u]!=0;u=fa[u]){ int f=fa[u]; ll len=getdis(now,f); sum[f]+=w; sum_dis[f]+=1ll*w*len; sum_f[u]+=1ll*w*len; } } il ll calc(int u){ ll res=sum_dis[u]; int now=u; for(;fa[u]!=0;u=fa[u]){ int f=fa[u]; ll len=getdis(now,f); res+=(sum[f]-sum[u])*len; res+=(sum_dis[f]-sum_f[u]); } return res; } ll ans; il void solve(ll u){ ans=calc(u); // cerr&lt;&lt;u&lt;&lt;&#39; &#39;&lt;&lt;ans&lt;&lt;endl; for(register int i=nhead[u];i;i=g[i].nxt){ int v=g[i].v,w=g[i].w; ll tmp=calc(w); // cerr&lt;&lt;w&lt;&lt;&#39; &#39;&lt;&lt;tmp&lt;&lt;endl; if(tmp&lt;ans){ solve(v);return;} } } il void pre(int u){ vis[u]=1; repe(i,u){ int v=e[i].v; if(vis[v]) continue; nxtroot(v,u); fa[root]=u; n_add_edge(u,root,v); pre(root); } } int main(){ n=read();int Q=read(); rep(i,2,n){ int u=read(),v=read(),w=read();link(u,v,w);} mx[0]=n+1; slpf::init(); int RT; nxtroot(1,1); RT=root; pre(root); // rep(i,1,n) cerr&lt;&lt;fa[i]&lt;&lt;&#39; &#39;; while(Q--){ int u=read(),e=read(); modify(u,e); // rep(i,1,n) cerr&lt;&lt;sum[i]&lt;&lt;&#39; &#39;&lt;&lt;sum_dis[i]&lt;&lt;endl; solve(RT); printf(&quot;%lld\\n&quot;,ans); } return 0; }","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"难度:中等","slug":"难度-中等","permalink":"/tags/难度-中等/"},{"name":"贪心","slug":"贪心","permalink":"/tags/贪心/"},{"name":"点分治","slug":"点分治","permalink":"/tags/点分治/"},{"name":"动态点分治","slug":"动态点分治","permalink":"/tags/动态点分治/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"[ZJOI2007]捉迷藏","slug":"ZJOI2007-捉迷藏","date":"2020-04-01T06:54:34.000Z","updated":"2021-02-10T15:19:51.000Z","comments":true,"path":"2020/04/01/ZJOI2007-捉迷藏/","link":"","permalink":"/2020/04/01/ZJOI2007-捉迷藏/","excerpt":"","text":"ProblemDescriptionJiajia 和 Wind 是一对恩爱的夫妻，并且他们有很多孩子。某天，Jiajia、Wind 和孩子们决定在家里玩捉迷藏游戏。他们的家很大且构造很奇特，由 $N$个屋子和$ N-1 $条双向走廊组成，这$N-1$条走廊的分布使得任意两个屋子都互相可达。游戏是这样进行的，孩子们负责躲藏，Jiajia 负责找，而 Wind 负责操纵这 $N$个屋子的灯。在起初的时候，所有的灯都没有被打开。每一次，孩子们只会躲藏在没有开灯的房间中，但是为了增加刺激性，孩子们会要求打开某个房间的电灯或者关闭某个房间的电灯。为了评估某一次游戏的复杂性，Jiajia 希望知道可能的最远的两个孩子的距离（即最远的两个关灯房间的距离）。我们将以如下形式定义每一种操作：C(hange) i 改变第 i个房间的照明状态，若原来打开，则关闭；若原来关闭，则打开。G(ame) 开始一次游戏，查询最远的两个关灯房间的距离。Input第一行包含一个整数 $N$，表示房间的个数，房间将被编号为 1,2,3…$N$ 的整数。接下来$ N-1$行每行两个整数$a$, $b$，表示房间 $a$ 与房间 $b$ 之间有一条走廊相连。接下来一行包含一个整数 $Q$，表示操作次数。接着 $Q$ 行，每行一个操作，如上文所示。Output对于每一个操作 Game，输出一个非负整数，表示最远的两个关灯房间的距离。若只有一个房间是关着灯的，输出 0；若所有房间的灯都开着，输出 -1。Sample Input8 1 2 2 3 3 4 3 5 3 6 6 7 6 8 7 G C 1 G C 2 G C 1 G Sample Output4 3 3 4 HINT对于20%的数据， $N \\leq 50$, $Q\\leq 100$；对于60%的数据， $N \\leq 3000$, $Q \\leq 10000$对于100%的数据， $N \\leq 100000$, $Q \\leq 500000$SolutionAnalysis这里给出动态点分治的一个做法（括号序列做法也许以后会补？)简单而言就是堆去维护每个点它能到达最深的点，两条边相加。这样子做会出现不合法的，那就再维护堆对于该点的每个儿子。Attention简单证明一下淀粉树的正确性（防止我自己迷惑，应该大家都会这个证明（我太菜了））：每个点把树分成了$\\sum children$个部分，这些部分都互相连边，且其余的边一定不经过$root$，那么分治下去就是子问题。（所以淀粉树上两点的距离即使不是1也是可以正确的）（这好像就是点分治的正确性emmm）Code自带大常数，好乱啊（也许会重构？//Code by Enderturtle #include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define repe(i,a) for(register int i=head[a];i;i=e[i].nxt) #define il inline #define pii pair&lt;int,int&gt; #define mp(a,b) make_pair(a,b) typedef long long ll; using namespace std; il void filejudge(){ freopen(&quot;.in&quot;,&quot;r&quot;,stdin); freopen(&quot;.out&quot;,&quot;w&quot;,stdout); } il int read(){ int x=0;bool f=1;char ch=getchar(); while(!isdigit(ch)){if(ch==&#39;-&#39;) f=0;ch=getchar();} while(isdigit(ch)){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();} return f?x:-x; } /*----- head end -----*/ const int N=100010; int n,cnt; struct node{ priority_queue&lt;int&gt; q1,q2; il void push(int x){ q1.push(x);} il void erase(int x){ q2.push(x);} il int size(){ return q1.size()-q2.size();} il int top(){ while(!q2.empty() &amp;&amp; q1.top()==q2.top()) q1.pop(),q2.pop(); return q1.top(); } il void pop(){ while(!q2.empty() &amp;&amp; q1.top()==q2.top()) q1.pop(),q2.pop(); q1.pop(); } il int top2(){ int tmp=top();pop(); int res=top();push(tmp); return res; } } h1[N],h2[N],ans; struct Edge{ int v,nxt;} e[N&lt;&lt;1];int tot,head[N]; il void add_edge(int u,int v){ e[++tot]=(Edge){v,head[u]};head[u]=tot;} il void link(int u,int v){ add_edge(u,v),add_edge(v,u);} namespace slpf{ int sz[N],fa[N],top[N],son[N],dep[N]; il void dfs1(int u,int f){ sz[u]=1;dep[u]=dep[f]+1;fa[u]=f; repe(i,u){ int v=e[i].v; if(v==f) continue; dfs1(v,u); sz[u]+=sz[v]; if(sz[v]&gt;sz[son[u]]) son[u]=v; } } il void dfs2(int u,int topf){ top[u]=topf; if(!son[u]) return; dfs2(son[u],topf); repe(i,u){ int v=e[i].v; if(v==fa[u] || v==son[u]) continue; dfs2(v,v); } } il void init(){ dfs1(1,1);dfs2(1,1);} il int lca(int u,int v){ while(top[u]!=top[v]){ if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); u=fa[top[u]]; } if(dep[u]&gt;dep[v]) swap(u,v); return u; } il int getdis(int u,int v){ int c=lca(u,v); return dep[u]+dep[v]-2*dep[c]; } } using slpf::getdis; int sz[N],fa[N],mx[N],treesz,root;bool vis[N],st[N]; il void getsz(int u,int f){ sz[u]=1; repe(i,u){ int v=e[i].v; if(v==f || vis[v]) continue; getsz(v,u); sz[u]+=sz[v]; } } il void getroot(int u,int f){ mx[u]=0; repe(i,u){ int v=e[i].v; if(v==f || vis[v]) continue; getroot(v,u); mx[u]=max(mx[u],sz[v]); } mx[u]=max(mx[u],treesz-mx[u]); if(mx[u]&lt;mx[root]) root=u; } il void nxtroot(int u,int f){ getsz(u,f); root=0;treesz=sz[u]; getroot(u,f); } il void calc(int id,int u,int f){ if(!st[u]) h2[root].push(getdis(u,id)); repe(i,u){ int v=e[i].v; if(v==f || vis[v]) continue; calc(id,v,u); } } il void solve(int u){ vis[u]=1; if(!st[u]) h1[u].push(0); repe(i,u){ int v=e[i].v; if(vis[v]) continue; nxtroot(v,u); fa[root]=u; calc(u,root,root); if(h2[root].size()) h1[u].push(h2[root].top()); solve(root); } if(h1[u].size()&gt;1) ans.push(h1[u].top()+h1[u].top2()); } il void turn_on(int u){ st[u]=1;cnt--; if(h1[u].size()&gt;1) ans.erase(h1[u].top()+h1[u].top2()); h1[u].erase(0); if(h1[u].size()&gt;1) ans.push(h1[u].top()+h1[u].top2()); int now=u; for(;fa[u]!=0;u=fa[u]){ int f=fa[u]; if(h1[f].size()&gt;1) ans.erase(h1[f].top()+h1[f].top2()); int dis=getdis(now,f); h1[f].erase(h2[u].top()); h2[u].erase(dis); if(h2[u].size()) h1[f].push(h2[u].top()); if(h1[f].size()&gt;1) ans.push(h1[f].top()+h1[f].top2()); } } il void turn_off(int u){ st[u]=0;cnt++; if(h1[u].size()&gt;1) ans.erase(h1[u].top()+h1[u].top2()); h1[u].push(0); if(h1[u].size()&gt;1) ans.push(h1[u].top()+h1[u].top2()); int now=u; for(;fa[u]!=0;u=fa[u]){ int f=fa[u]; if(h1[f].size()&gt;1) ans.erase(h1[f].top()+h1[f].top2()); int dis=getdis(now,f); if(h2[u].size()) h1[f].erase(h2[u].top()); h2[u].push(dis); h1[f].push(h2[u].top()); if(h1[f].size()&gt;1) ans.push(h1[f].top()+h1[f].top2()); } } char opt[3]; int main(){ n=read(); rep(i,2,n){ int u=read(),v=read();link(u,v);} slpf::init(); mx[0]=n+1;cnt=n; nxtroot(1,1); solve(root); int Q=read(); while(Q--){ scanf(&quot;%s&quot;,opt); if(opt[0]==&#39;G&#39;){ if(cnt&lt;=1) printf(&quot;%d\\n&quot;,cnt-1); else printf(&quot;%d\\n&quot;,ans.top()); }else{ int x=read(); if(st[x]) turn_off(x); else turn_on(x); } } return 0; }","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"难度:中等","slug":"难度-中等","permalink":"/tags/难度-中等/"},{"name":"树链剖分","slug":"树链剖分","permalink":"/tags/树链剖分/"},{"name":"点分治","slug":"点分治","permalink":"/tags/点分治/"},{"name":"动态点分治","slug":"动态点分治","permalink":"/tags/动态点分治/"},{"name":"删除堆","slug":"删除堆","permalink":"/tags/删除堆/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"矩阵","slug":"矩阵","date":"2019-12-31T12:37:23.000Z","updated":"2021-07-21T10:29:53.711Z","comments":false,"path":"2019/12/31/矩阵/","link":"","permalink":"/2019/12/31/矩阵/","excerpt":"The article has been encrypted, please enter your password to view.","text":"Please enter the password to read the blog. Incorrect Password! No content to display! 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","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"难度:困难","slug":"难度-困难","permalink":"/tags/难度-困难/"},{"name":"线性基","slug":"线性基","permalink":"/tags/线性基/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"[LGOJ3620][APIO/CTSC2007]数据备份","slug":"LGOJ3620-APIO-CTSC2007-数据备份","date":"2019-12-26T11:37:46.000Z","updated":"2021-02-10T15:19:51.000Z","comments":true,"path":"2019/12/26/LGOJ3620-APIO-CTSC2007-数据备份/","link":"","permalink":"/2019/12/26/LGOJ3620-APIO-CTSC2007-数据备份/","excerpt":"","text":"ProblemDescription你在一家 IT 公司为大型写字楼或办公楼(offices)的计算机数据做备份。然而数据备份的工作是枯燥乏味的，因此你想设计一个系统让不同的办公楼彼此之间互相备份，而你则坐在家中尽享计算机游戏的乐趣。 已知办公楼都位于同一条街上。你决定给这些办公楼配对(两个一组)。每一对办公楼可以通过在这两个建筑物之间铺设网络电缆使得它们可以互相备份。 然而，网络电缆的费用很高。当地电信公司仅能为你提供 K 条网络电缆，这意味着你仅能为 K 对办公楼(或总计 2K 个办公楼)安排备份。任一个办公楼都属于唯一的配对组(换句话说，这 2K 个办公楼一定是相异的)。 此外，电信公司需按网络电缆的长度(公里数)收费。因而，你需要选择这 K对办公楼使得电缆的总长度尽可能短。换句话说，你需要选择这 K 对办公楼，使得每一对办公楼之间的距离之和(总距离)尽可能小。 下面给出一个示例，假定你有 5 个客户，其办公楼都在一条街上，如下图所示。这 5 个办公楼分别位于距离大街起点 1km, 3km, 4km, 6km 和 12km 处。电信公司仅为你提供 K=2 条电缆。 上例中最好的配对方案是将第 1 个和第 2 个办公楼相连，第 3 个和第 4 个办公楼相连。这样可按要求使用 K=2 条电缆。第 1 条电缆的长度是 3km―1km = 2km，第 2 条电缆的长度是 6km―4km = 2 km。这种配对方案需要总长 4km 的网络电缆，满足距离之和最小的要求。Input输入文件的第一行包含整数 n 和 k，其中 n(1≤n≤100 000)表示办公楼的数目，k(1≤k≤n/2)表示可利用的网络电缆的数目。 接下来的 n 行每行仅包含一个整数(0≤s≤1000 000 000), 表示每个办公楼到大街起点处的距离。这些整数将按照从小到大的顺序依次出现。Output输出文件应当由一个正整数组成，给出将 2K 个相异的办公楼连成 K 对所需的网络电缆的最小总长度。Sample Input5 2 1 3 4 6 12 Sample Output4 HINT30%的输入数据满足 n≤20。 60%的输入数据满足 n≤10 000SolutionAnalysis考虑抽象后的题目给定n-1个点，选k个不相邻的点使其和最小考虑贪心每次选最小的，但这样显然是不优秀的如下例子：2 1 2 10 （k=2）先选1是不优秀的对于这种情况我们考虑添加一个反悔机制即当我们选择了a[i]我们重新令a[i]=a[i].lst+a[i].nxt-a[i]即解决问题Attention注意赋值infCode//Code by Enderturtle #include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define repe(i,a) for(register int i=head[a];i;i=e[i].nxt) #define il inline #define pii pair&lt;int,int&gt; #define mp(a,b) make_pair(a,b) typedef long long ll; using namespace std; il void filejudge(){ freopen(&quot;.in&quot;,&quot;r&quot;,stdin); freopen(&quot;.out&quot;,&quot;w&quot;,stdout); } il int read(){ int x=0;bool f=1;char ch=getchar(); while(!isdigit(ch)){if(ch==&#39;-&#39;) f=0;ch=getchar();} while(isdigit(ch)){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();} return f?x:-x; } /*----- head end -----*/ const int N=100010; int n,k; ll s[N]; struct my_list{ int lst,nxt; ll res; } a[N]; bool usd[N]; il void del(int id){ // del id.lst id.nxt a[id].lst=a[a[id].lst].lst; a[id].nxt=a[a[id].nxt].nxt; a[a[id].lst].nxt=id; a[a[id].nxt].lst=id; } struct node{ int id; ll res; bool operator &lt;(const node &amp; other) const{ return res&gt;other.res; } }; priority_queue&lt;node&gt; q; ll ans=0; int main(){ n=read();k=read(); rep(i,1,n) scanf(&quot;%lld&quot;,&amp;s[i]); rep(i,1,n-1){ a[i].lst=i-1; a[i].nxt=i+1; a[i].res=s[i+1]-s[i]; q.push((node){i,a[i].res}); } a[0].res=a[n].res=LLONG_MAX/3; while(k&gt;0 &amp;&amp; !q.empty()){ int id=q.top().id;ll res=q.top().res;q.pop(); if(usd[id]) continue; k--; ans+=res; usd[a[id].lst]=usd[a[id].nxt]=1; a[id].res=a[a[id].lst].res+a[a[id].nxt].res-a[id].res; q.push((node){id,a[id].res}); del(id); } printf(&quot;%lld\\n&quot;,ans); return 0; }","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"难度:中等","slug":"难度-中等","permalink":"/tags/难度-中等/"},{"name":"贪心","slug":"贪心","permalink":"/tags/贪心/"},{"name":"链表","slug":"链表","permalink":"/tags/链表/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"PNYWE-D1","slug":"PNYWE-DAY1","date":"2019-12-25T13:38:48.000Z","updated":"2021-02-10T15:19:51.000Z","comments":false,"path":"2019/12/25/PNYWE-DAY1/","link":"","permalink":"/2019/12/25/PNYWE-DAY1/","excerpt":"The article has been encrypted, please enter your password to view.","text":"Please enter the password to read the blog. Incorrect Password! No content to display! U2FsdGVkX1+4/ByXZ507Pyiypgsrg+wZ36JVXoX6moffq3hQ7P1DPT6KqdFnnZGDtKq3dk+hX13XHRHYS4K5mw+i0/1Tikvk7W9M9PtfYX/2eSOhLWb/AwaYzPV7bRXA0vvkk9UKCUue7n7gOCKrwFRjlHqnIn2ALJ/YAPzZS4OXgbiwg1Ew9lYnplNrMDaZk2ww5BIu9L8tvIzfS1PE2TvCDKxndmxs/mMQMUQdsmzz4szclVy+1Hxsm0eQxhXGIY/9Cpg4aUs4B+Z6qWs2OxIRFLdzyoFWzIUkGPA6C6v320ONpWiePOf5uY7sooox6ffBk9BankgK4buarYMO+oth4Lmw1PcI5pWTY9Wed3molQf8dhiOlHyCu8pQYds6xb9ibxzkfNi+t00JbKJd7eK9CbTwcQDSlFVgXnkC9uYYPCp9Su64Pyg3DBc9JB1l9+8XBfeKwP6gwVeyvtjC01WFcFmGYqj17K3bMZrsWhBk7AwmcAJXySik7pjISKwTSVa+cf3HNnSMzXi0XfYrRqqAIrnCI4ia7i9xVJtOOuSlHAB1Oi9FiukNlZ89/q/aLI/uR4iN3Ky56/MNCuFzTs0MsLEXqItUCZePdLrxRu0IY/TmZW2rDhMg5UUW+cou/aY3DPRf15Oy36eWuvfELZ170ijSab0+KcLvoe7GPUVPvQUwBtvyE7wjhX27CvLQ8XbvIVUfCXreavyleRETS+mNYtssOcojff7HBmI6IP85b4/s0VAnYlZcxCeM6roJloru2/xJUKH9tGNriyYEECAeuOqW8FzbuzueOI2zfyqytyBZfXgwlz0bx0N/eebrMavpLgZAllg48CHKqpl+nb4RtOpF2Sh1Pbq6PjNOX+ec67LY3bXnSZnPi2M8S+3G65tAg1SGGMscjTVb3lAbHoXPt0uX5gaMbG9RZ9OJhqRbfDgke6oTpRVO/O8hAD1PBuanZDxt82lnJKWG5sRo2zEGCEmTDtqznmgete0dT+RTVeFPW6upK54FsI6sRIAxKOgGlnLztuSbiGj/+nKWzg/Z7kHD6trLhlS6dPRU3GnitzRl4c/9FX1aYgjjrHEyD8PtXxOSBneR0uSJ/cRq42NIH/+i62KktGJH2D/2/kX/AKx0yto95wd4a5Wx7M4SP3JPCYXMvVBBXjICBU4vX+Xe5RJytHXRjchcZIA8coLDIx9TdojGMomhhGTHuOTfu8GBPGdaW7hs+YAI+RNt21P0rB+NDv7SnZkBEy/v0x9+sRAHR58OPoIIxgwLvFA2PDIJOpyHref8wXlXXw1FceF/VeQ/Tzu/ukIP+mhAWEuGta4yG42axVMVQb8TqUkL2fvs+n2gBkAFjGh8OJJo4MJ7OPlYme68ThDKF2A229E=","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"/tags/贪心/"},{"name":"搜索","slug":"搜索","permalink":"/tags/搜索/"},{"name":"构造","slug":"构造","permalink":"/tags/构造/"},{"name":"CRT","slug":"CRT","permalink":"/tags/CRT/"},{"name":"meet in middle","slug":"meet-in-middle","permalink":"/tags/meet-in-middle/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"[LGOJ3313][SDOI2014] 旅行","slug":"LGOJ3313-SDOI2014-旅行","date":"2019-12-24T12:50:48.000Z","updated":"2021-02-10T15:19:51.000Z","comments":true,"path":"2019/12/24/LGOJ3313-SDOI2014-旅行/","link":"","permalink":"/2019/12/24/LGOJ3313-SDOI2014-旅行/","excerpt":"","text":"ProblemDescriptionS国有N个城市，编号从1到N。城市间用N-1条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。为了方便，我们用不同的正整数代表各种宗教， S国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S国政府为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。在S国的历史上常会发生以下几种事件：”CC x c”：城市x的居民全体改信了c教；”CW x w”：城市x的评级调整为w;”QS x y”：一位旅行者从城市x出发，到城市y，并记下了途中留宿过的城市的评级总和；”QM x y”：一位旅行者从城市x出发，到城市y，并记下了途中留宿过的城市的评级最大值。由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。 为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。Input输入的第一行包含整数N，Q依次表示城市数和事件数。接下来N行，第i+l行两个整数Wi，Ci依次表示记录开始之前，城市i的评级和信仰。接下来N-1行每行两个整数x，y表示一条双向道路。接下来Q行，每行一个操作，格式如上所述。Output对每个QS和QM事件，输出一行，表示旅行者记下的数字。Sample Input5 6 3 1 2 3 1 2 3 3 5 1 1 2 1 3 3 4 3 5 QS 1 5 CC 3 1 QS 1 5 CW 3 3 QS 1 5 QM 2 4 Sample Output8 9 11 3 HINTN，Q &lt; =10^5，C &lt; =10^5数据保证对所有QS和QM事件，起点和终点城市的信仰相同；在任意时刻，城市的评级总是不大于10^4的正整数，且宗教值不大于C。SolutionAnalysis宗教不是很多，直接全上线段树就行Attention无Code//Code by Enderturtle #include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define repe(i,a) for(register int i=head[a];i;i=e[i].nxt) #define il inline #define pii pair&lt;int,int&gt; #define debug cerr&lt;&lt;&quot;OK Here&quot;&lt;&lt;endl; typedef long long ll; using namespace std; il void filejudge(){ freopen(&quot;.in&quot;,&quot;r&quot;,stdin); freopen(&quot;.out&quot;,&quot;w&quot;,stdout); } il int read(){ int x=0;bool f=1;char ch=getchar(); while(!isdigit(ch)){if(ch==&#39;-&#39;) f=0;ch=getchar();} while(isdigit(ch)){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();} return f?x:-x; } /*----- head end -----*/ const int N=100010; const int M=10000010; struct Edge{ int v,nxt; } e[N&lt;&lt;1];int head[N],tot; il void add_edge(int u,int v){ e[++tot]=(Edge){v,head[u]}; head[u]=tot; } /*--------------------*/ int n,m; int w[N],col[N]; /*--------------------*/ int sz[N],son[N],fa[N],top[N],dep[N]; int in[N],dfs_clock; il void dfs1(int u,int f){ dep[u]=dep[f]+1;sz[u]=1;fa[u]=f; repe(i,u){ int v=e[i].v; if(v==f) continue; dfs1(v,u); sz[u]+=sz[v]; if(sz[v]&gt;sz[son[u]]) son[u]=v; } } il void dfs2(int u,int topf){ top[u]=topf;in[u]=++dfs_clock; if(!son[u]) return; dfs2(son[u],topf); repe(i,u){ int v=e[i].v; if(v==fa[u] || v==son[u]) continue; dfs2(v,v); } } il int lca(int u,int v){ while(top[u]!=top[v]){ if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); u=fa[top[u]]; } return dep[u]&gt;dep[v]?v:u; } /*--------------------*/ int ls[M],rs[M],mx[M],sum[M],cnt; int root[N]; il void up(int o){ mx[o]=max(mx[ls[o]],mx[rs[o]]); sum[o]=sum[ls[o]]+sum[rs[o]]; } il void modify(int &amp;o,int x,int L,int R,int c){ if(!o) o=++cnt; if(L==R){ mx[o]=sum[o]=c; return; } int mid=(L+R)&gt;&gt;1; if(x&lt;=mid) modify(ls[o],x,L,mid,c); else modify(rs[o],x,mid+1,R,c); up(o); } il int query_sum(int o,int l,int r,int L,int R){ if(!o) return 0; if(L==l &amp;&amp; R==r) return sum[o]; int mid=(L+R)&gt;&gt;1,res=0; if(l&lt;=mid) res=query_sum(ls[o],l,min(r,mid),L,mid); if(r&gt;mid) res+=query_sum(rs[o],max(l,mid+1),r,mid+1,R); return res; } il int query_max(int o,int l,int r,int L,int R){ if(!o) return 0; if(L==l &amp;&amp; R==r) return mx[o]; int mid=(L+R)&gt;&gt;1,res=0; if(l&lt;=mid) res=query_max(ls[o],l,min(r,mid),L,mid); if(r&gt;mid) res=max(res,query_max(rs[o],max(l,mid+1),r,mid+1,R)); return res; } /*--------------*/ il int solve_sum(int x,int y,int c){ int res=0; while(top[x]!=top[y]){ res+=query_sum(root[c],in[top[x]],in[x],1,n); x=fa[top[x]]; } res+=query_sum(root[c],in[y],in[x],1,n); return res; } il int solve_max(int x,int y,int c){ int res=0; while(top[x]!=top[y]){ res=max(res,query_max(root[c],in[top[x]],in[x],1,n)); x=fa[top[x]]; } res=max(res,query_max(root[c],in[y],in[x],1,n)); return res; } int main(){ n=read();m=read(); rep(i,1,n) w[i]=read(),col[i]=read(); rep(i,2,n){ int u=read(),v=read(); add_edge(u,v); add_edge(v,u); } dfs1(1,1); dfs2(1,1); rep(i,1,n) modify(root[col[i]],in[i],1,n,w[i]); while(m--){ char opt[3];scanf(&quot;%s&quot;,opt); if(opt[0]==&#39;C&#39; &amp;&amp; opt[1]==&#39;C&#39;){ int x=read(),c=read(); modify(root[col[x]],in[x],1,n,0); col[x]=c; modify(root[col[x]],in[x],1,n,w[x]); }else if(opt[0]==&#39;C&#39; &amp;&amp; opt[1]==&#39;W&#39;){ int x=read(),c=read(); modify(root[col[x]],in[x],1,n,c); w[x]=c; }else if(opt[0]==&#39;Q&#39; &amp;&amp; opt[1]==&#39;S&#39;){ int x=read(),y=read(); int c=lca(x,y); printf(&quot;%d\\n&quot;,solve_sum(x,c,col[y])+solve_sum(y,c,col[y])-((col[c]==col[y])?w[c]:0)); }else if(opt[0]==&#39;Q&#39; &amp;&amp; opt[1]==&#39;M&#39;){ int x=read(),y=read(); int c=lca(x,y); printf(&quot;%d\\n&quot;,max(solve_max(x,c,col[y]),solve_max(y,c,col[y]))); } } return 0; }","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"难度:简单","slug":"难度-简单","permalink":"/tags/难度-简单/"},{"name":"线段树","slug":"线段树","permalink":"/tags/线段树/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"},{"name":"树链剖分","slug":"树链剖分","permalink":"/tags/树链剖分/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"[LGOJ2982][Usaco2010 Feb] Slowing down","slug":"LGOJ2982-Usaco2010-Feb-Slowing-down","date":"2019-12-24T03:46:20.000Z","updated":"2021-02-10T15:19:51.000Z","comments":true,"path":"2019/12/24/LGOJ2982-Usaco2010-Feb-Slowing-down/","link":"","permalink":"/2019/12/24/LGOJ2982-Usaco2010-Feb-Slowing-down/","excerpt":"","text":"ProblemDescriptionEvery day each of Farmer John’s N (1 &lt;= N &lt;= 100,000) cows conveniently numbered 1..N move from the barn to her private pasture. The pastures are organized as a tree, with the barn being on pasture 1. Exactly N-1 cow unidirectional paths connect the pastures; directly connected pastures have exactly one path. Path i connects pastures A_i and B_i (1 &lt;= A_i &lt;= N; 1 &lt;= B_i &lt;= N).Cow i has a private pasture P_i (1 &lt;= P_i &lt;= N). The barn’s small door lets only one cow exit at a time; and the patient cows wait until their predecessor arrives at her private pasture. First cow 1 exits and moves to pasture P_1. Then cow 2 exits and goes to pasture P_2, and so on.While cow i walks to P_i she might or might not pass through a pasture that already contains an eating cow. When a cow is present in a pasture, cow i walks slower than usual to prevent annoying her friend.Consider the following pasture network, where the number between parentheses indicates the pastures&#39; owner. 1 (3) / \\ (1) 4 3 (5) / \\ (2) 2 5 (4) First, cow 1 walks to her pasture: 1 (3) / \\ [1] 4* 3 (5) / \\ (2) 2 5 (4) When cow 2 moves to her pasture, she first passes into the barn&#39;s pasture, pasture 1. Then she sneaks around cow 1 in pasture 4 before arriving at her own pasture. 1 (3) / \\ [1] 4* 3 (5) / \\ [2] 2* 5 (4) Cow 3 doesn&#39;t get far at all -- she lounges in the barn&#39;s pasture, #1. 1* [3] / \\ [1] 4* 3 (5) / \\ [2] 2* 5 (4) Cow 4 must slow for pasture 1 and 4 on her way to pasture 5: 1* [3] / \\ [1] 4* 3 (5) / \\ [2] 2* 5* [4] Cow 5 slows for cow 3 in pasture 1 and then enters her own private pasture: 1* [3] / \\ [1] 4* 3*[5] / \\ [2] 2* 5* [4] Input* Line 1: Line 1 contains a single integer: N* Lines 2..N: Line i+1 contains two space-separated integers: A_i and B_i* Lines N+1..N+N: line N+i contains a single integer: P_iOutput* Lines 1..N: Line i contains the number of times cow i has to slow down.Sample Input5 1 4 5 4 1 3 2 4 4 2 1 5 3 Sample Output0 1 0 2 1 HINT无SolutionAnalysisdfs序维护子树信息Attention无Code//Code by Enderturtle #include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define repe(i,a) for(register int i=head[a];i;i=e[i].nxt) #define il inline #define lowbit(x) (x&amp;-x) #define pii pair&lt;int,int&gt; #define mp(a,b) make_pair(a,b) typedef long long ll; using namespace std; il void filejudge(){ freopen(&quot;.in&quot;,&quot;r&quot;,stdin); freopen(&quot;.out&quot;,&quot;w&quot;,stdout); } il int read(){ int x=0;bool f=1;char ch=getchar(); while(!isdigit(ch)){if(ch==&#39;-&#39;) f=0;ch=getchar();} while(isdigit(ch)){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();} return f?x:-x; } /*----- head end -----*/ const int N=100010; int n; struct Edge{ int v,nxt; } e[N&lt;&lt;1];int head[N],tot; il void add_edge(int u,int v){ e[++tot]=(Edge){v,head[u]}; head[u]=tot; } int c[N]; int in[N],out[N],cnt; il void dfs(int u,int fa){ in[u]=++cnt; repe(i,u){ int v=e[i].v; if(v==fa) continue; dfs(v,u); } out[u]=cnt; } il void add(int x,int addv){ for(;x&lt;=n+1;x+=lowbit(x)){ c[x]+=addv; } } il int query(int x){ int res=0; for(;x&gt;0;x-=lowbit(x)) res+=c[x]; return res; } int main(){ n=read(); rep(i,2,n){ int u=read(),v=read(); add_edge(u,v); add_edge(v,u); } dfs(1,1); rep(i,1,n){ int a=read(); printf(&quot;%d\\n&quot;,query(in[a])); add(in[a],1); add(out[a]+1,-1); } return 0; }","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"难度:简单","slug":"难度-简单","permalink":"/tags/难度-简单/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"},{"name":"dfs序","slug":"dfs序","permalink":"/tags/dfs序/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"[CF413E] Maze 2D","slug":"CF413E-Maze-2D","date":"2019-12-24T03:12:09.000Z","updated":"2021-02-10T15:19:51.000Z","comments":true,"path":"2019/12/24/CF413E-Maze-2D/","link":"","permalink":"/2019/12/24/CF413E-Maze-2D/","excerpt":"","text":"ProblemDescriptionThe last product of the R2 company in the 2D games’ field is a new revolutionary algorithm of searching for the shortest path in a 2 × nmaze.Imagine a maze that looks like a 2 × n rectangle, divided into unit squares. Each unit square is either an empty cell or an obstacle. In one unit of time, a person can move from an empty cell of the maze to any side-adjacent empty cell. The shortest path problem is formulated as follows. Given two free maze cells, you need to determine the minimum time required to go from one cell to the other.Unfortunately, the developed algorithm works well for only one request for finding the shortest path, in practice such requests occur quite often. You, as the chief R2 programmer, are commissioned to optimize the algorithm to find the shortest path. Write a program that will effectively respond to multiple requests to find the shortest path in a 2 × n maze.InputThe first line contains two integers, n and m (1 ≤ n ≤ 2·105; 1 ≤ m ≤ 2·105) — the width of the maze and the number of queries, correspondingly. Next two lines contain the maze. Each line contains n characters, each character equals either ‘.‘ (empty cell), or ‘X‘ (obstacle).Each of the next m lines contains two integers v**i and u**i (1 ≤ v**i, u**i ≤ 2n) — the description of the i-th request. Numbers v**i, u**i mean that you need to print the value of the shortest path from the cell of the maze number v**i to the cell number u**i. We assume that the cells of the first line of the maze are numbered from 1 to n, from left to right, and the cells of the second line are numbered from n + 1 to 2n from left to right. It is guaranteed that both given cells are empty.OutputPrint m lines. In the i-th line print the answer to the i-th request — either the size of the shortest path or -1, if we can’t reach the second cell from the first one.Sample Input4 7 .X.. ...X 5 1 1 3 7 7 1 4 6 1 4 7 5 7 Sample Output4 7 .X.. ...X 5 1 1 3 7 7 1 4 6 1 4 7 5 7 HINT无SolutionAnalysis直接进行查询操作Attention无Code//Code by Enderturtle #include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define repe(i,a) for(register int i=head[a];i;i=e[i].nxt) #define il inline #define pii pair&lt;int,int&gt; #define mp(a,b) make_pair(a,b) typedef long long ll; using namespace std; il void filejudge(){ freopen(&quot;.in&quot;,&quot;r&quot;,stdin); freopen(&quot;.out&quot;,&quot;w&quot;,stdout); } il int read(){ int x=0;bool f=1;char ch=getchar(); while(!isdigit(ch)){if(ch==&#39;-&#39;) f=0;ch=getchar();} while(isdigit(ch)){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();} return f?x:-x; } /*----- head end -----*/ const int N=200001; const int inf=0x3f3f3f3f; int n,m; char a[3][N]; #define ls (o&lt;&lt;1) #define rs ((o&lt;&lt;1)|1) struct node{ int d1,d2,d3,d4; }t[N&lt;&lt;2]; //d1 左上-&gt;右上 //d2 左上-&gt;右下 //d3 左下-&gt;右上 //d4 左下-&gt;右下 il node merge(node A,node B){ node res; res.d1=min(inf,min(A.d1+B.d1,A.d2+B.d3)+1); res.d2=min(inf,min(A.d1+B.d2,A.d2+B.d4)+1); res.d3=min(inf,min(A.d3+B.d1,A.d4+B.d3)+1); res.d4=min(inf,min(A.d4+B.d4,A.d3+B.d2)+1); return res; } il node query(int o,int l,int r,int L,int R){ if(l==L &amp;&amp; r==R) return t[o]; int mid=(L+R)&gt;&gt;1; if(r&lt;=mid) return query(ls,l,r,L,mid); if(l&gt;mid) return query(rs,l,r,mid+1,R); return merge(query(ls,l,mid,L,mid),query(rs,mid+1,r,mid+1,R)); } il void build(int o,int l,int r){ if(l==r){ t[o].d1=t[o].d2=t[o].d3=t[o].d4=inf; if(a[1][l]==&#39;.&#39;) t[o].d1=0; if(a[2][l]==&#39;.&#39;) t[o].d4=0; if(a[1][l]==&#39;.&#39; &amp;&amp; a[2][l]==&#39;.&#39;) t[o].d2=t[o].d3=1; return; } int mid=(l+r)&gt;&gt;1; build(ls,l,mid);build(rs,mid+1,r); t[o]=merge(t[ls],t[rs]); } int main(){ n=read();m=read(); rep(i,1,2) scanf(&quot;%s&quot;,a[i]+1); build(1,1,n); while(m--){ int x=read(),y=read(); bool se1=0,se2=0; if(x&gt;n) x-=n,se1=1; if(y&gt;n) y-=n,se2=1; if(x&gt;y){ swap(x,y); swap(se1,se2); } node ans=query(1,x,y,1,n); if(se1){ if(se2) printf(&quot;%d\\n&quot;,(ans.d4==inf)?-1:ans.d4); else printf(&quot;%d\\n&quot;,(ans.d3==inf)?-1:ans.d3); }else{ if(se2) printf(&quot;%d\\n&quot;,(ans.d2==inf)?-1:ans.d2); else printf(&quot;%d\\n&quot;,(ans.d1==inf)?-1:ans.d1); } } return 0; }","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"难度:简单","slug":"难度-简单","permalink":"/tags/难度-简单/"},{"name":"线段树","slug":"线段树","permalink":"/tags/线段树/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"欢迎有缘人进入","slug":"欢迎有缘人进入","date":"2019-12-23T11:11:25.000Z","updated":"2021-02-10T15:19:51.000Z","comments":false,"path":"2019/12/23/欢迎有缘人进入/","link":"","permalink":"/2019/12/23/欢迎有缘人进入/","excerpt":"The article has been encrypted, please enter your password to view.","text":"密码是我喜欢的数字 Incorrect Password! No content to display! U2FsdGVkX1+fqFiWLCORYW73aNo9WCZJiAVV4f0N7JwrNIU1CBNGTEvyY/wADVLkXZgzvArrQZSt5P5d1jLu+w5wu8kkxvbUDPuziTSPWmHiHG3hR5cXOppb6I9xOUK7irDH+hAc7ZtNiOzVDjmkLZxUig74VBXgBZA6bHSrlUV7s0ejtmKyAAz05kD8X2tihm5HnNlFF75rfp3CT3VQE727PCzlODMQXw1BbQxbyuVeGOS+ik/qxtgtS6G2V9ysHsDAFsxf6OivCAto9VnHlhY9vSzfPDJsa0BmAQnJkM91mTg2IPPwDB9dIrT9aFbZ2cN0oL0egRRYe/AKnKNdLjknvo0H+mrBveFeOLshd+5YusiE29CJx45nlpbqy8T7a6WF9iGNAbia4cz0/WwSbp5WKU4sBvabI8Lulq/9fvTjGvjPVEG00LTYi/zvFYtcQVAiCy/s2uY+yvYBvGLFKyBtXtem3V8jUIkqJlsduRFasA0AJzDeQPaw5obD36KKBuND5OBArzRfutFba/FpZg==","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"[LGOJ2486][SDOI2011] 染色","slug":"LGOJ2486-SDOI2011-染色","date":"2019-12-23T05:35:23.000Z","updated":"2021-02-10T15:19:51.000Z","comments":true,"path":"2019/12/23/LGOJ2486-SDOI2011-染色/","link":"","permalink":"/2019/12/23/LGOJ2486-SDOI2011-染色/","excerpt":"","text":"ProblemDescription给定一棵有n个节点的无根树和m个操作，操作有2类：1、将节点a到节点b路径上所有点都染成颜色c；2、询问节点a到节点b路径上的颜色段数量（连续相同颜色被认为是同一段），如“112221”由3段组成：“11”、“222”和“1”。请你写一个程序依次完成这m个操作。Input第一行包含2个整数n和m，分别表示节点数和操作数；第二行包含n个正整数表示n个节点的初始颜色下面 行每行包含两个整数x和y，表示x和y之间有一条无向边。下面 行每行描述一个操作：“C a b c”表示这是一个染色操作，把节点a到节点b路径上所有点（包括a和b）都染成颜色c；“Q a b”表示这是一个询问操作，询问节点a到节点b（包括a和b）路径上的颜色段数量。Output对于每个询问操作，输出一行答案。Sample Input6 5 2 2 1 2 1 1 1 2 1 3 2 4 2 5 2 6 Q 3 5 C 2 1 1 Q 3 5 C 5 1 2 Q 3 5 Sample Output3 1 2 HINT$n,m \\leq 10^5 $$col\\leq10^9$SolutionAnalysis建立树链（重链）剖分和线段树。线段树维护三个信息：答案，左颜色，右颜色即可。Attention合并两个树上路径可以先找lca,然后query(u,lca)+query(v,lca)-1即为答案Code//Code by Enderturtle #include&lt;bits/stdc++.h&gt; #define rep(i,a,b) for(register int i=a;i&lt;=b;++i) #define repe(i,a) for(register int i=head[a];i;i=e[i].nxt) #define il inline #define pii pair&lt;int,int&gt; #define mp(a,b) make_pair(a,b) typedef long long ll; using namespace std; il int read(){ int x=0;bool f=1;char ch=getchar(); while(!isdigit(ch)){if(ch==&#39;-&#39;) f=0;ch=getchar();} while(isdigit(ch)){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();} return f?x:-x; } /*----- head end -----*/ int n,m; const int N=1e5+10; struct Edge{ int v,nxt; } e[N&lt;&lt;1];int head[N],tot; il void add(int u,int v){ e[++tot]=(Edge){v,head[u]}; head[u]=tot; } int dep[N],son[N],sz[N],top[N],fa[N]; il void dfs1(int u,int f){ fa[u]=f;dep[u]=dep[f]+1;sz[u]=1; repe(i,u){ int v=e[i].v; if(v==f) continue; dfs1(v,u); sz[u]+=sz[v]; if(sz[v]&gt;sz[son[u]]) son[u]=v; } } int in[N],a[N],col[N],dfs_clock; il void dfs2(int u,int topf){ in[u]=++dfs_clock;top[u]=topf; a[dfs_clock]=col[u]; if(!son[u]) return; dfs2(son[u],topf); repe(i,u){ int v=e[i].v; if(v==fa[u] || v==son[u]) continue; dfs2(v,v); } } il int lca(int u,int v){ while(top[u]!=top[v]){ if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); u=fa[top[u]]; } return (dep[u]&gt;dep[v])?v:u; } /*-------------*/ struct node{ int sum; int l_col,r_col; } t[N&lt;&lt;2]; int lazy[N&lt;&lt;2]; #define ls (o&lt;&lt;1) #define rs ((o&lt;&lt;1)|1) il void up(int o){ t[o].sum=t[ls].sum+t[rs].sum-(t[ls].r_col==t[rs].l_col); t[o].l_col=t[ls].l_col; t[o].r_col=t[rs].r_col; } il void push_down(int o){ if(!lazy[o]) return; t[ls].sum=t[rs].sum=1; t[ls].l_col=t[ls].r_col=t[rs].l_col=t[rs].r_col=lazy[o]; lazy[ls]=lazy[rs]=lazy[o]; lazy[o]=0; } il void build(int o,int l,int r){ if(l==r){ t[o].sum=1; t[o].l_col=t[o].r_col=a[l]; return; } int mid=(l+r)&gt;&gt;1; build(ls,l,mid);build(rs,mid+1,r); up(o); } il node query(int o,int l,int r,int L,int R){ if(l==L &amp;&amp; r==R) return t[o]; push_down(o); int mid=(L+R)&gt;&gt;1; node lson,rson,res; lson.sum=lson.l_col=lson.r_col=0; rson.sum=rson.l_col=rson.r_col=0; if(l&lt;=mid) lson=query(ls,l,min(mid,r),L,mid); if(r&gt;mid) rson=query(rs,max(l,mid+1),r,mid+1,R); res.sum=lson.sum+rson.sum-(lson.r_col==rson.l_col); if(lson.l_col!=0){ res.l_col=lson.l_col; }else res=rson; if(rson.r_col!=0){ res.r_col=rson.r_col; }else res=lson; return res; } il void update(int o,int l,int r,int L,int R,int change){ if(l==L &amp;&amp; r==R){ t[o].sum=1; t[o].l_col=t[o].r_col=change; lazy[o]=change; return; } push_down(o); int mid=(L+R)&gt;&gt;1; if(l&lt;=mid) update(ls,l,min(mid,r),L,mid,change); if(r&gt;mid) update(rs,max(l,mid+1),r,mid+1,R,change); up(o); } /*----------------*/ il int query_col(int u,int c){ node res; res.l_col=res.sum=res.r_col=0; while(top[u]!=top[c]){ node tmp=query(1,in[top[u]],in[u],1,n); if(res.r_col==0) res=tmp; else{ res.sum+=(tmp.sum-(tmp.r_col==res.l_col)); res.l_col=tmp.l_col; } u=fa[top[u]]; } node tmp=query(1,in[c],in[u],1,n); if(res.r_col==0) res=tmp; else res.sum+=(tmp.sum-(tmp.r_col==res.l_col)); return res.sum; } il void update_dis(int u,int c,int change){ while(top[u]!=top[c]){ update(1,in[top[u]],in[u],1,n,change); u=fa[top[u]]; } update(1,in[c],in[u],1,n,change); } int main(){ n=read();m=read(); rep(i,1,n) col[i]=read(); rep(i,2,n){ int u=read(),v=read(); add(u,v); add(v,u); } dfs1(1,1); dfs2(1,1); build(1,1,n); while(m--){ char opt[2];scanf(&quot;%s&quot;,opt); if(opt[0]==&#39;C&#39;){ int u=read(),v=read(),change=read(); int c=lca(u,v); update_dis(u,c,change); update_dis(v,c,change); }else{ int u=read(),v=read(); int c=lca(u,v); printf(&quot;%d\\n&quot;,query_col(u,c)+query_col(v,c)-1); } } return 0; }","categories":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}],"tags":[{"name":"难度:简单","slug":"难度-简单","permalink":"/tags/难度-简单/"},{"name":"线段树","slug":"线段树","permalink":"/tags/线段树/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"},{"name":"树链剖分","slug":"树链剖分","permalink":"/tags/树链剖分/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"/categories/OI/"}]},{"title":"New_Blog","slug":"New_Blog","date":"2019-12-22T10:00:00.000Z","updated":"2021-07-09T08:56:07.294Z","comments":true,"path":"2019/12/22/New_Blog/","link":"","permalink":"/2019/12/22/New_Blog/","excerpt":"","text":"开荒第一篇留作纪念","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"博客相关","slug":"博客相关","permalink":"/tags/博客相关/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]}]}